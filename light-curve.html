<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Adaptive Lighting – Brightness Colored by CCT + Sun (TZ dropdown + hover)</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  body{font-family:sans-serif;margin:1.5rem;background:#f5f5f5;}
  .container{max-width:1200px;margin:0 auto;background:#fff;padding:2rem;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.1);}  
  h2{margin-top:0;color:#333;}
  h3{margin-top:2rem;color:#555;}
  .controls{display:grid;grid-template-columns:220px 1fr 120px;gap:8px;align-items:center;margin-bottom:1rem}
  input[type=range]{width:100%}
  input[type=text]{width:100%;padding:6px 8px;border:1px solid #ddd;border-radius:6px}
  select{width:100%;padding:6px 8px;border:1px solid #ddd;border-radius:6px;background:#fff}
  label{font-size:.85rem;font-weight:600;color:#666}
  .stage{margin:2rem 0}
  .note{font-size:.9rem;color:#666;margin-bottom:1rem}
  .warn{color:#a33;font-size:.85rem}
</style>
</head>
<body>
<div class="container">
  <h2>Adaptive Lighting – Brightness Curve (Colorized by CCT)</h2>
  <div class="note">
    Left Y-axis: Brightness (colored by CCT). Right Y-axis: Sun elevation (blue). Month is 1–12. Lat/Lon are text inputs. Time zone via dropdown (DST auto by month).
  </div>

  <div id="plot" class="stage"></div>

  <h3>Parameters</h3>
  <div id="ctrl-params" class="controls"></div>
  <div id="range-warn" class="warn"></div>
</div>

<script>
// --------------------------- Params ---------------------------------
const params = {
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  gamma: 2,
  gamma_bri: 1.5,
  month: 7,            // 1..12 (default July)
  latitude: 35.0,      // degrees (N + / S -)
  longitude: -78.6,    // degrees (E + / W -)
  timezone: 'US/Eastern'
};

// Range sliders: [key, min, default, max, step, label]
const sliders = [
  ['min_color_temp', 500, 500, 6500, 50, 'Min CCT (K)'],
  ['max_color_temp', 500, 6500, 6500, 50, 'Max CCT (K)'],
  ['min_brightness', 0, 1, 50, 1, 'Min Brightness (%)'],
  ['max_brightness', 50, 100, 100, 1, 'Max Brightness (%)'],
  ['gamma', 0.2, 2, 5, 0.1, 'CCT Gamma'],
  ['gamma_bri', 0.2, 1.5, 5, 0.1, 'Brightness Gamma'],
  ['month', 1, 7, 12, 1, 'Month (1–12)']
];

// Text inputs (no sliders)
const textInputs = [
  ['latitude',  'Latitude (°; N+, S-)'],
  ['longitude', 'Longitude (°; E+, W-)']
];

// Time zone dropdown options
const TZ_OPTIONS = [
  {id:'US/Eastern',  label:'US/Eastern'},
  {id:'US/Central',  label:'US/Central'},
  {id:'US/Mountain', label:'US/Mountain'},
  {id:'US/Pacific',  label:'US/Pacific'},
  {id:'US/Alaska',   label:'US/Alaska'},
  {id:'US/Arizona',  label:'US/Arizona (no DST)'},
  {id:'US/Hawaii',   label:'US/Hawaii (no DST)'}
];

// Compute UTC offset (hours) for given zone & month (mid-month rules)
// DST months: Mar–Oct (3..10). Nov–Feb standard. Arizona/Hawaii never DST.
function utcOffsetFor(zone, month){
  const dst = (zone !== 'US/Arizona' && zone !== 'US/Hawaii') && (month >= 3 && month <= 10);
  switch(zone){
    case 'US/Eastern':  return dst ? -4 : -5;
    case 'US/Central':  return dst ? -5 : -6;
    case 'US/Mountain': return dst ? -6 : -7;
    case 'US/Pacific':  return dst ? -7 : -8;
    case 'US/Alaska':   return dst ? -8 : -9;
    case 'US/Arizona':  return -7;
    case 'US/Hawaii':   return -10;
    default: return -5; // fallback Eastern
  }
}

// ------------------------- Helpers ----------------------------------
function smoothstep(x){ x = Math.max(0, Math.min(1, x)); return x*x*(3-2*x); }
const timeToPos = h => -Math.cos((2*Math.PI*h)/24);

// Approximate black-body CCT (K) to RGB (0-255)
function cctToRGB(k){
  k = Math.max(500, Math.min(6500, k));
  let t = k/100, r,g,b;
  if (t <= 66) r = 255; else r = 329.698727446 * Math.pow(t - 60, -0.1332047592);
  if (t <= 66) g = 99.4708025861 * Math.log(t) - 161.1195681661;
  else g = 288.1221695283 * Math.pow(t - 60, -0.0755148492);
  if (t >= 66) b = 255;
  else if (t <= 19) b = 0;
  else b = 138.5177312231 * Math.log(t - 10) - 305.0447927307;
  const clamp = v => Math.max(0, Math.min(255, Math.round(v)));
  return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
}

const CUM_DAYS = [0,31,59,90,120,151,181,212,243,273,304,334]; // start-of-month (non-leap)
function doyForMonthMid(m){ return CUM_DAYS[m-1] + 15; } // m: 1..12

function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

// Solar declination (radians)
function solarDeclinationRad(doy){
  const g = 2*Math.PI/365 * (doy - 1);
  return 0.006918
       - 0.399912*Math.cos(g) + 0.070257*Math.sin(g)
       - 0.006758*Math.cos(2*g) + 0.000907*Math.sin(2*g)
       - 0.002697*Math.cos(3*g) + 0.00148 *Math.sin(3*g);
}

// Equation of Time (minutes)
function equationOfTimeMinutes(doy){
  const B = 2*Math.PI*(doy - 81)/364;
  return 9.87*Math.sin(2*B) - 7.53*Math.cos(B) - 1.5*Math.sin(B);
}

// Local Solar Time (hours)
function localSolarTimeHours(clockHour, utcOffset, longitude, doy){
  const LSTM = 15 * utcOffset;                          // meridian (deg)
  const TC_min = equationOfTimeMinutes(doy) + 4*(longitude - LSTM); // minutes
  return clockHour + TC_min/60;
}

function hourAngleRad(clockHour, utcOffset, longitude, doy){
  const LST = localSolarTimeHours(clockHour, utcOffset, longitude, doy);
  return deg2rad(15*(LST - 12));
}

// Sun elevation (degrees)
function sunElevationDeg(clockHour, month, latDeg, lonDeg, tzName){
  const doy = doyForMonthMid(month);
  const utcOffset = utcOffsetFor(tzName, month);
  const phi = deg2rad(latDeg);
  const delta = solarDeclinationRad(doy);
  const H = hourAngleRad(clockHour, utcOffset, lonDeg, doy);
  const sinAlt = Math.sin(phi)*Math.sin(delta) + Math.cos(phi)*Math.cos(delta)*Math.cos(H);
  return rad2deg(Math.asin(sinAlt));
}

function compute(){
  const hours=[], ccts=[], bris=[], sunEl=[];
  const doy = doyForMonthMid(params.month);
  const utcOffset = utcOffsetFor(params.timezone, params.month);

  for (let hour=0; hour<=24; hour+=0.1){
    // Use local solar time so the peak occurs at LST = 12 (solar noon)
    const lst = localSolarTimeHours(hour, utcOffset, params.longitude, doy);

    // Same shape, just driven by LST instead of wall clock
    const pos = timeToPos(lst);              // was: timeToPos(hour)
    const t = (pos+1)*0.5;                   // 0..1

    const tGammaCCT = Math.pow(t, params.gamma);
    const sCCT = smoothstep(tGammaCCT);
    const cct = params.min_color_temp + sCCT*(params.max_color_temp - params.min_color_temp);

    const tGammaB = Math.pow(t, params.gamma_bri);
    const sB = smoothstep(tGammaB);
    const bri = params.min_brightness + sB*(params.max_brightness - params.min_brightness);

    hours.push(hour);                         // keep X as CLOCK time for readability
    ccts.push(cct);
    bris.push(bri);
    sunEl.push(sunElevationDeg(hour, params.month, params.latitude, params.longitude, params.timezone));
  }
  return {hours, ccts, bris, sunEl};
}

// Build many tiny line segments so each can be colorized by CCT
function buildBrightnessColoredByCCT(x, bri, cct){
  const segs = [];
  for (let i=1; i<x.length; i++){
    const midCCT = (cct[i-1]+cct[i])/2;
    segs.push({
      type: 'scatter',
      mode: 'lines',
      x: [x[i-1], x[i]],
      y: [bri[i-1], bri[i]],
      line: {width: 4, color: cctToRGB(midCCT)},
      name: 'Brightness (%)',
      yaxis: 'y',
      hoverinfo: 'skip', // hover is handled by a transparent proxy trace below
      showlegend: false
    });
  }
  return segs;
}

function enforceRanges(){
  const warn = document.getElementById('range-warn');
  warn.textContent = '';
  if (params.min_color_temp > params.max_color_temp){
    const tmp = params.min_color_temp;
    params.min_color_temp = params.max_color_temp;
    params.max_color_temp = tmp;
    warn.textContent = 'Note: Min CCT exceeded Max; values swapped.';
  }
  // Clamp month to 1..12
  params.month = Math.min(12, Math.max(1, Math.round(params.month)));
}

// Render
function renderPlot(x, cct, bri, sunEl){
  const segs = buildBrightnessColoredByCCT(x, bri.map(v=>Math.round(v)), cct);

  // Legend proxy for the colored brightness line
  const legendProxy = {
    type:'scatter', mode:'lines', x:[null], y:[null],
    name:'Brightness (%)',
    line:{width:4, color: cctToRGB((params.min_color_temp+params.max_color_temp)/2)},
    hoverinfo:'skip', showlegend:true, yaxis:'y'
  };

  // Transparent hover proxy to show CCT + Brightness at the exact mouse position
  const hoverProxy = {
    type:'scatter', mode:'lines',
    x: x,
    y: bri,
    name: 'Brightness (hover)',
    line: {width: 10, color: 'rgba(0,0,0,0)'},
    hovertemplate: 'Hour %{x:.1f}<br>Brightness %{y:.0f}%<br>CCT %{customdata:.0f} K<extra></extra>',
    customdata: cct, // expose CCT alongside brightness
    yaxis: 'y',
    showlegend: false
  };

  const sunTrace = {
    type:'scatter', mode:'lines',
    x: x, y: sunEl,
    name: 'Sun Elevation (°)',
    line: {width: 2, color: 'blue'},
    yaxis: 'y2',
    hovertemplate: 'Hour %{x:.1f}<br>Sun %{y:.1f}°<extra></extra>'
  };

  Plotly.newPlot('plot', [...segs, legendProxy, hoverProxy, sunTrace], {
    title: 'Brightness over Time (colored by CCT) + Sun Elevation (Lat/Lon & US TZ)',
    xaxis: {title:'Clock Time (hours)', range:[0,24], dtick:3},
    yaxis:  {title:'Brightness (%)', range:[0,105], autorange:false},
    yaxis2: {title:'Sun Elevation (°)', overlaying:'y', side:'right', range:[-10,90]},
    showlegend:true, legend:{x:0.02,y:0.98}, margin:{t:50}
  }, {responsive:true});
}

function draw(){
  enforceRanges();
  const {hours, ccts, bris, sunEl} = compute();
  renderPlot(hours, ccts, bris, sunEl);
}

// Build controls
function makePanel(){
  const panel = document.getElementById('ctrl-params');

  // Range sliders
  sliders.forEach(([key, min, val, max, step, label]) => {
    const lab = document.createElement('label'); lab.textContent = label;
    const rng = document.createElement('input');
    rng.type='range'; rng.min=min; rng.max=max; rng.step=step; rng.value=val;
    const out = document.createElement('span'); out.textContent = val;
    rng.oninput = e => {
      const num = (key==='month') ? parseInt(e.target.value,10) : parseFloat(e.target.value);
      params[key] = num;
      out.textContent = e.target.value;
      draw();
    };
    panel.append(lab, rng, out);
    params[key] = (key==='month') ? val|0 : val;
  });

  // Text inputs for lat/lon
  textInputs.forEach(([key, label]) => {
    const lab = document.createElement('label'); lab.textContent = label;
    const txt = document.createElement('input');
    txt.type = 'text';
    txt.value = params[key];
    const out = document.createElement('span'); out.textContent = params[key];
    const commit = () => {
      const v = parseFloat(txt.value);
      if (!Number.isNaN(v)) {
        params[key] = v;
        out.textContent = v;
        draw();
      } else {
        txt.value = params[key]; // revert
      }
    };
    txt.onblur = commit;
    txt.onkeydown = e => { if (e.key === 'Enter') { txt.blur(); } };
    panel.append(lab, txt, out);
  });

  // Time zone dropdown
  {
    const lab = document.createElement('label'); lab.textContent = 'US Time Zone';
    const sel = document.createElement('select');
    TZ_OPTIONS.forEach(opt => {
      const o = document.createElement('option');
      o.value = opt.id; o.textContent = opt.label;
      if (opt.id === params.timezone) o.selected = true;
      sel.appendChild(o);
    });
    const out = document.createElement('span'); out.textContent = params.timezone;
    sel.onchange = e => { params.timezone = e.target.value; out.textContent = params.timezone; draw(); };
    panel.append(lab, sel, out);
  }
}

// Init
makePanel();
draw();
</script>
</body>
</html>
