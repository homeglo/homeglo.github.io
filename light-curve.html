<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Adaptive Lighting – Brightness Colored by CCT</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  body{font-family:sans-serif;margin:1.5rem;background:#f5f5f5;}
  .container{max-width:1200px;margin:0 auto;background:#fff;padding:2rem;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.1);}  
  h2{margin-top:0;color:#333;}
  h3{margin-top:2rem;color:#555;}
  .controls{display:grid;grid-template-columns:180px 1fr 60px;gap:8px;align-items:center;margin-bottom:1rem}
  input[type=range]{width:100%}
  label{font-size:.85rem;font-weight:600;color:#666}
  .stage{margin:2rem 0}
  .note{font-size:.9rem;color:#666;margin-bottom:1rem}
  .warn{color:#a33;font-size:.85rem}
</style>
</head>
<body>
<div class="container">
  <h2>Adaptive Lighting – Brightness Curve (Colorized by CCT)</h2>
  <div class="note">Single brightness curve on the Y-axis. Segment color = CCT at that time.</div>

  <div id="plot" class="stage"></div>

  <h3>Parameters</h3>
  <div id="ctrl-params" class="controls"></div>
  <div id="range-warn" class="warn"></div>
</div>

<script>
// --------------------------- Params ---------------------------------
const params = {
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  gamma: 2,
  gamma_bri: 1.5
};

// Slider specs: [key, min, default, max, step, label]
const sliders = [
  ['min_color_temp', 500, 500, 6500, 50, 'Min CCT (K)'],
  ['max_color_temp', 500, 6500, 6500, 50, 'Max CCT (K)'],
  ['min_brightness', 0, 1, 50, 1, 'Min Brightness (%)'],
  ['max_brightness', 50, 100, 100, 1, 'Max Brightness (%)'],
  ['gamma', 0.2, 2, 5, 0.1, 'CCT Gamma'],
  ['gamma_bri', 0.2, 1.5, 5, 0.1, 'Brightness Gamma']
];

// ------------------------- Helpers ----------------------------------
function smoothstep(x){ x = Math.max(0, Math.min(1, x)); return x*x*(3-2*x); }
const timeToPos = h => -Math.cos((2*Math.PI*h)/24);

// Approximate black-body CCT (K) to RGB (0-255)
function cctToRGB(k){
  k = Math.max(500, Math.min(6500, k));
  let t = k/100;
  let r,g,b;
  if (t <= 66) r = 255; else r = 329.698727446 * Math.pow(t - 60, -0.1332047592);
  if (t <= 66) g = 99.4708025861 * Math.log(t) - 161.1195681661;
  else g = 288.1221695283 * Math.pow(t - 60, -0.0755148492);
  if (t >= 66) b = 255;
  else if (t <= 19) b = 0;
  else b = 138.5177312231 * Math.log(t - 10) - 305.0447927307;
  const clamp = v => Math.max(0, Math.min(255, Math.round(v)));
  return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
}

// Compute curves
function compute(){
  const hours=[], ccts=[], bris=[];
  for (let hour=0; hour<=24; hour+=0.1){
    const pos = timeToPos(hour);
    const t = (pos+1)*0.5; // 0..1

    const tGammaCCT = Math.pow(t, params.gamma);
    const sCCT = smoothstep(tGammaCCT);
    const cct = params.min_color_temp + sCCT*(params.max_color_temp - params.min_color_temp);

    const tGammaB = Math.pow(t, params.gamma_bri);
    const sB = smoothstep(tGammaB);
    const bri = params.min_brightness + sB*(params.max_brightness - params.min_brightness);

    hours.push(hour);
    ccts.push(cct);
    bris.push(bri);
  }
  return {hours, ccts, bris};
}

// Build many tiny line segments so each can be colorized by CCT
function buildBrightnessColoredByCCT(x, bri, cct){
  const segs = [];
  for (let i=1; i<x.length; i++){
    const midCCT = (cct[i-1]+cct[i])/2;
    segs.push({
      type: 'scatter',
      mode: 'lines',
      x: [x[i-1], x[i]],
      y: [bri[i-1], bri[i]],
      line: {width: 4, color: cctToRGB(midCCT)},
      hoverinfo: 'skip',
      showlegend: false,
      name: 'Brightness (%)'
    });
  }
  return segs;
}

function enforceRanges(){
  const warn = document.getElementById('range-warn');
  warn.textContent = '';
  if (params.min_color_temp > params.max_color_temp){
    const tmp = params.min_color_temp;
    params.min_color_temp = params.max_color_temp;
    params.max_color_temp = tmp;
    warn.textContent = 'Note: Min CCT exceeded Max; values swapped.';
  }
}

// Use a different function name than "plot" to avoid collisions with the #plot div id.
function renderPlot(x, cct, bri){
  const segs = buildBrightnessColoredByCCT(x, bri.map(v=>Math.round(v)), cct);

  // Legend proxy so something shows up in legend
  const legendProxy = {
    type:'scatter',
    mode:'lines',
    x:[null],
    y:[null],
    name:'Brightness (%)',
    line:{width:4, color: cctToRGB((params.min_color_temp+params.max_color_temp)/2)},
    hoverinfo:'skip',
    showlegend:true
  };

  Plotly.newPlot('plot', [...segs, legendProxy], {
    title: 'Brightness over Time (colored by CCT)',
    xaxis: {title:'Time of Day (hours)', range:[0,24], dtick:3},
    yaxis: {title:'Brightness (%)', range:[0,105], autorange:false},
    showlegend:true, legend:{x:0.02,y:0.98}, margin:{t:50}
  }, {responsive:true});
}

function draw(){
  enforceRanges();
  const {hours, ccts, bris} = compute();
  renderPlot(hours, ccts, bris);
}

// Build slider UI
function makePanel(){
  const panel = document.getElementById('ctrl-params');
  sliders.forEach(([key, min, val, max, step, label]) => {
    const lab = document.createElement('label'); lab.textContent = label;
    const rng = document.createElement('input');
    rng.type='range'; rng.min=min; rng.max=max; rng.step=step; rng.value=val;
    const out = document.createElement('span'); out.textContent = val;
    rng.oninput = e => { params[key] = parseFloat(e.target.value); out.textContent = e.target.value; draw(); };
    panel.append(lab, rng, out);
    params[key] = val;
  });
}

// Init
makePanel();
draw();
</script>
</body>
</html>
