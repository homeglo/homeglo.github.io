<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Adaptive Lighting – Brightness Colored by CCT + Sun (fixed solar noon)</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  body{font-family:sans-serif;margin:1.5rem;background:#f5f5f5;}
  .container{max-width:1200px;margin:0 auto;background:#fff;padding:2rem;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.1);}  
  h2{margin-top:0;color:#333;}
  h3{margin-top:2rem;color:#555;}
  .controls{display:grid;grid-template-columns:220px 1fr 120px;gap:8px;align-items:center;margin-bottom:1rem}
  input[type=range]{width:100%}
  input[type=text]{width:100%;padding:6px 8px;border:1px solid #ddd;border-radius:6px}
  select{width:100%;padding:6px 8px;border:1px solid #ddd;border-radius:6px;background:#fff}
  label{font-size:.85rem;font-weight:600;color:#666}
  .stage{margin:2rem 0}
  .note{font-size:.9rem;color:#666;margin-bottom:1rem}
  .warn{color:#a33;font-size:.85rem}
</style>
</head>
<body>
<div class="container">
  <h2>Adaptive Lighting – Brightness Curve (Colorized by CCT)</h2>
  <div class="note">
    Brightness (left Y, colored by CCT) is mapped to solar elevation at your lat/lon. Sun elevation (right Y, blue). Month 1–12. Lat/Lon text inputs. US time zone dropdown (DST handled correctly).
  </div>

  <div id="plot" class="stage"></div>

  <h3>Parameters</h3>
  <div id="ctrl-params" class="controls"></div>
  <div id="range-warn" class="warn"></div>
</div>

<script>
// --------------------------- Params ---------------------------------
const params = {
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  gamma: 2,
  gamma_bri: 1.5,
  month: 7,            // 1..12
  latitude: 35.0,      // deg (N+, S-)
  longitude: -78.6,    // deg (E+, W-)
  timezone: 'US/Eastern'
};

// Sliders: [key, min, def, max, step, label]
const sliders = [
  ['min_color_temp', 500, 500, 6500, 50, 'Min CCT (K)'],
  ['max_color_temp', 500, 6500, 6500, 50, 'Max CCT (K)'],
  ['min_brightness', 0, 1, 50, 1, 'Min Brightness (%)'],
  ['max_brightness', 50, 100, 100, 1, 'Max Brightness (%)'],
  ['gamma', 0.2, 2, 5, 0.1, 'CCT Gamma'],
  ['gamma_bri', 0.2, 1.5, 5, 0.1, 'Brightness Gamma'],
  ['month', 1, 7, 12, 1, 'Month (1–12)']
];

// Text inputs
const textInputs = [
  ['latitude',  'Latitude (°; N+, S-)'],
  ['longitude', 'Longitude (°; E+, W-)']
];

// Time zone dropdown options
const TZ_OPTIONS = [
  {id:'US/Eastern',  label:'US/Eastern'},
  {id:'US/Central',  label:'US/Central'},
  {id:'US/Mountain', label:'US/Mountain'},
  {id:'US/Pacific',  label:'US/Pacific'},
  {id:'US/Alaska',   label:'US/Alaska'},
  {id:'US/Arizona',  label:'US/Arizona (no DST)'},
  {id:'US/Hawaii',   label:'US/Hawaii (no DST)'}
];

// ------------------------- Solar helpers -----------------------------
const CUM_DAYS = [0,31,59,90,120,151,181,212,243,273,304,334]; // non-leap
function doyForMonthMid(m){ return CUM_DAYS[m-1] + 15; }

function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

function solarDeclinationRad(doy){
  const g = 2*Math.PI/365 * (doy - 1);
  return 0.006918
       - 0.399912*Math.cos(g) + 0.070257*Math.sin(g)
       - 0.006758*Math.cos(2*g) + 0.000907*Math.sin(2*g)
       - 0.002697*Math.cos(3*g) + 0.00148 *Math.sin(3*g);
}
function equationOfTimeMinutes(doy){
  const B = 2*Math.PI*(doy - 81)/364;
  return 9.87*Math.sin(2*B) - 7.53*Math.cos(B) - 1.5*Math.sin(B);
}

// Standard vs DST offsets (hours)
function standardOffset(zone){
  switch(zone){
    case 'US/Eastern':  return -5;
    case 'US/Central':  return -6;
    case 'US/Mountain': return -7;
    case 'US/Pacific':  return -8;
    case 'US/Alaska':   return -9;
    case 'US/Arizona':  return -7;
    case 'US/Hawaii':   return -10;
    default: return -5;
  }
}
function isDST(zone, month){
  return (zone !== 'US/Arizona' && zone !== 'US/Hawaii') && (month >= 3 && month <= 10);
}
function currentOffset(zone, month){
  const std = standardOffset(zone);
  return isDST(zone, month) ? std + 1 : std;
}

// Local Solar Time (hours) — IMPORTANT FIX:
// 1) Convert local clock (possibly DST) -> local *standard* time
// 2) Use LSTM from *standard* offset
function localSolarTimeHours(clockHour, zone, month, longitude, doy){
  const stdOff = standardOffset(zone);
  const curOff = currentOffset(zone, month);
  const clockStd = clockHour - (curOff - stdOff);   // subtract 1h during DST
  const LSTM = 15 * stdOff;                         // standard meridian in degrees
  const TC_min = equationOfTimeMinutes(doy) + 4*(longitude - LSTM);
  return clockStd + TC_min/60;
}
function hourAngleRad(clockHour, zone, month, longitude, doy){
  const LST = localSolarTimeHours(clockHour, zone, month, longitude, doy);
  return deg2rad(15*(LST - 12));
}
function sunElevationDeg(clockHour, month, latDeg, lonDeg, zone){
  const doy = doyForMonthMid(month);
  const phi = deg2rad(latDeg);
  const delta = solarDeclinationRad(doy);
  const H = hourAngleRad(clockHour, zone, month, lonDeg, doy);
  const sinAlt = Math.sin(phi)*Math.sin(delta) + Math.cos(phi)*Math.cos(delta)*Math.cos(H);
  return rad2deg(Math.asin(sinAlt));
}

// -------------------- Curve mapping (lat/lon-aware) ------------------
const ALT_NIGHT = -6;  // civil twilight end
const ALT_DAY   = 60;  // full daylight reference
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function smoothstep(x){ x = clamp01(x); return x*x*(3-2*x); }

function cctToRGB(k){
  k = Math.max(500, Math.min(6500, k));
  let t = k/100, r,g,b;
  if (t <= 66) r = 255; else r = 329.698727446 * Math.pow(t - 60, -0.1332047592);
  if (t <= 66) g = 99.4708025861 * Math.log(t) - 161.1195681661;
  else g = 288.1221695283 * Math.pow(t - 60, -0.0755148492);
  if (t >= 66) b = 255;
  else if (t <= 19) b = 0;
  else b = 138.5177312231 * Math.log(t - 10) - 305.0447927307;
  const clamp = v => Math.max(0, Math.min(255, Math.round(v)));
  return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
}

// Compute curves
function compute(){
  const hours=[], ccts=[], bris=[], sunEl=[];
  for (let hour=0; hour<=24; hour+=0.1){
    const el = sunElevationDeg(hour, params.month, params.latitude, params.longitude, params.timezone);
    sunEl.push(el);

    const t_raw = (el - ALT_NIGHT) / (ALT_DAY - ALT_NIGHT);
    const t_day = clamp01(t_raw);

    const tGammaCCT = Math.pow(t_day, params.gamma);
    const sCCT = smoothstep(tGammaCCT);
    const cct = params.min_color_temp + sCCT*(params.max_color_temp - params.min_color_temp);

    const tGammaB = Math.pow(t_day, params.gamma_bri);
    const sB = smoothstep(tGammaB);
    const bri = params.min_brightness + sB*(params.max_brightness - params.min_brightness);

    hours.push(hour);
    ccts.push(cct);
    bris.push(bri);
  }
  return {hours, ccts, bris, sunEl};
}

// Colored segments for brightness
function buildBrightnessColoredByCCT(x, bri, cct){
  const segs = [];
  for (let i=1; i<x.length; i++){
    const midCCT = (cct[i-1]+cct[i])/2;
    segs.push({
      type: 'scatter',
      mode: 'lines',
      x: [x[i-1], x[i]],
      y: [bri[i-1], bri[i]],
      line: {width: 4, color: cctToRGB(midCCT)},
      name: 'Brightness (%)',
      yaxis: 'y',
      hoverinfo: 'skip',
      showlegend: false
    });
  }
  return segs;
}

function enforceRanges(){
  const warn = document.getElementById('range-warn');
  warn.textContent = '';
  if (params.min_color_temp > params.max_color_temp){
    const tmp = params.min_color_temp;
    params.min_color_temp = params.max_color_temp;
    params.max_color_temp = tmp;
    warn.textContent = 'Note: Min CCT exceeded Max; values swapped.';
  }
  params.month = Math.min(12, Math.max(1, Math.round(params.month)));
}

// Render
function renderPlot(x, cct, bri, sunEl){
  const segs = buildBrightnessColoredByCCT(x, bri.map(v=>Math.round(v)), cct);

  const legendProxy = {
    type:'scatter', mode:'lines', x:[null], y:[null],
    name:'Brightness (%)',
    line:{width:4, color: cctToRGB((params.min_color_temp+params.max_color_temp)/2)},
    hoverinfo:'skip', showlegend:true, yaxis:'y'
  };

  const hoverProxy = {
    type:'scatter', mode:'lines',
    x: x,
    y: bri,
    name: 'Brightness (hover)',
    line: {width: 10, color: 'rgba(0,0,0,0)'},
    hovertemplate: 'Hour %{x:.1f}<br>Brightness %{y:.0f}%<br>CCT %{customdata:.0f} K<extra></extra>',
    customdata: cct,
    yaxis: 'y',
    showlegend: false
  };

  const sunTrace = {
    type:'scatter', mode:'lines',
    x: x, y: sunEl,
    name: 'Sun Elevation (°)',
    line: {width: 2, color: 'blue'},
    yaxis: 'y2',
    hovertemplate: 'Hour %{x:.1f}<br>Sun %{y:.1f}°<extra></extra>'
  };

  Plotly.newPlot('plot', [...segs, legendProxy, hoverProxy, sunTrace], {
    title: 'Brightness over Time (colored by CCT) + Sun Elevation (correct solar noon)',
    xaxis: {title:'Clock Time (hours)', range:[0,24], dtick:3},
    yaxis:  {title:'Brightness (%)', range:[0,105], autorange:false},
    yaxis2: {title:'Sun Elevation (°)', overlaying:'y', side:'right', range:[-10,90]},
    showlegend:true, legend:{x:0.02,y:0.98}, margin:{t:50}
  }, {responsive:true});
}

function draw(){
  enforceRanges();
  const {hours, ccts, bris, sunEl} = compute();
  renderPlot(hours, ccts, bris, sunEl);
}

// Build controls
function makePanel(){
  const panel = document.getElementById('ctrl-params');

  sliders.forEach(([key, min, val, max, step, label]) => {
    const lab = document.createElement('label'); lab.textContent = label;
    const rng = document.createElement('input');
    rng.type='range'; rng.min=min; rng.max=max; rng.step=step; rng.value=val;
    const out = document.createElement('span'); out.textContent = val;
    rng.oninput = e => {
      const num = (key==='month') ? parseInt(e.target.value,10) : parseFloat(e.target.value);
      params[key] = num;
      out.textContent = e.target.value;
      draw();
    };
    panel.append(lab, rng, out);
    params[key] = (key==='month') ? val|0 : val;
  });

  textInputs.forEach(([key, label]) => {
    const lab = document.createElement('label'); lab.textContent = label;
    const txt = document.createElement('input');
    txt.type = 'text';
    txt.value = params[key];
    const out = document.createElement('span'); out.textContent = params[key];
    const commit = () => {
      const v = parseFloat(txt.value);
      if (!Number.isNaN(v)) {
        params[key] = v;
        out.textContent = v;
        draw();
      } else {
        txt.value = params[key];
      }
    };
    txt.onblur = commit;
    txt.onkeydown = e => { if (e.key === 'Enter') { txt.blur(); } };
    panel.append(lab, txt, out);
  });

  // Time zone dropdown
  {
    const lab = document.createElement('label'); lab.textContent = 'US Time Zone';
    const sel = document.createElement('select');
    TZ_OPTIONS.forEach(opt => {
      const o = document.createElement('option');
      o.value = opt.id; o.textContent = opt.label;
      if (opt.id === params.timezone) o.selected = true;
      sel.appendChild(o);
    });
    const out = document.createElement('span'); out.textContent = params.timezone;
    sel.onchange = e => { params.timezone = e.target.value; out.textContent = params.timezone; draw(); };
    panel.append(lab, sel, out);
  }
}

// Init
makePanel();
draw();
</script>
</body>
</html>
