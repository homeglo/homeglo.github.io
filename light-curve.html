<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Adaptive Lighting – Formula Explorer</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  body{font-family:sans-serif;margin:1.5rem;background:#f5f5f5;}
  .container{max-width:1200px;margin:0 auto;background:#fff;padding:2rem;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.1);}  
  h2{margin-top:0;color:#333;}
  h3{margin-top:2rem;color:#555;}
  .controls{display:grid;grid-template-columns:180px 1fr 60px;gap:8px;align-items:center;margin-bottom:1rem}
  input[type=range]{width:100%}
  label{font-size:.85rem;font-weight:600;color:#666}
  .stage{margin:2rem 0}
  .note{font-size:.9rem;color:#666;margin-bottom:1rem}
  .warn{color:#a33;font-size:.85rem}
  button{background:#007acc;color:#fff;border:none;padding:.5rem 1.25rem;border-radius:4px;cursor:pointer;font-size:14px}
  button:hover{background:#005a99}
</style>
</head>
<body>
<div class="container">
  <h2>Adaptive Lighting – Formula Explorer</h2>
  <div class="note">CCT and Brightness curves use built‑in gamma + smoothstep (no custom formulas). CCT line is colorized by its Kelvin.</div>

  <!-- Plot -->
  <div id="plot" class="stage"></div>

  <!-- Parameters Controls -->
  <h3>Parameters</h3>
  <div id="ctrl-params" class="controls"></div>
  <div id="range-warn" class="warn"></div>
</div>

<script>
// --------------------------- Params ---------------------------------
const params = {
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  gamma: 2,
  gamma_bri: 1.5
};

// Slider specs: [key, min, default, max, step, label]
const sliders = [
  ['min_color_temp', 500, 500, 6500, 50, 'Min CCT (K)'],
  ['max_color_temp', 500, 6500, 6500, 50, 'Max CCT (K)'],
  ['min_brightness', 0, 1, 50, 1, 'Min Brightness (%)'],
  ['max_brightness', 50, 100, 100, 1, 'Max Brightness (%)'],
  ['gamma', 0.2, 2, 5, 0.1, 'CCT Gamma'],
  ['gamma_bri', 0.2, 1.5, 5, 0.1, 'Brightness Gamma']
];

// ------------------------- Helpers ----------------------------------
function smoothstep(x){ x = Math.max(0, Math.min(1, x)); return x*x*(3-2*x); }
const timeToPos = h => -Math.cos((2*Math.PI*h)/24);

// Approximate black-body CCT (K) to RGB (0-255) – classic algorithm
function cctToRGB(k){
  // Clamp to sensible range
  k = Math.max(500, Math.min(6500, k));
  let t = k/100; // use 100s
  let r, g, b;

  // Red
  if (t <= 66) r = 255; else r = 329.698727446 * Math.pow(t - 60, -0.1332047592);
  // Green
  if (t <= 66) g = 99.4708025861 * Math.log(t) - 161.1195681661; 
  else g = 288.1221695283 * Math.pow(t - 60, -0.0755148492);
  // Blue
  if (t >= 66) b = 255; 
  else if (t <= 19) b = 0; 
  else b = 138.5177312231 * Math.log(t - 10) - 305.0447927307;

  const clamp = v => Math.max(0, Math.min(255, Math.round(v)));
  return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
}

// Compute using built-in gamma+smoothstep curves
function compute(){
  const hours=[], ccts=[], bris=[];
  for (let hour=0; hour<=24; hour+=0.1){
    const pos = timeToPos(hour);
    const t = (pos+1)*0.5; // 0..1

    const tGammaCCT = Math.pow(t, params.gamma);
    const sCCT = smoothstep(tGammaCCT);
    const cct = params.min_color_temp + sCCT*(params.max_color_temp - params.min_color_temp);

    const tGammaB = Math.pow(t, params.gamma_bri);
    const sB = smoothstep(tGammaB);
    const bri = params.min_brightness + sB*(params.max_brightness - params.min_brightness);

    hours.push(hour);
    ccts.push(cct);
    bris.push(bri);
  }
  return {hours, ccts, bris};
}

// Build many tiny line segments so each can be colorized by its CCT
function buildCCTColoredSegments(x, y){
  const segs = [];
  for (let i=1; i<x.length; i++){
    const c = cctToRGB((y[i-1]+y[i])/2);
    segs.push({
      type: 'scatter', mode: 'lines', x: [x[i-1], x[i]], y: [y[i-1], y[i]],
      line: {width: 4, color: c}, hoverinfo: 'skip', showlegend: false, yaxis: 'y1', name: 'CCT (K)'
    });
  }
  return segs;
}

// Ensure valid ranges and give user feedback
function enforceRanges(){
  const warn = document.getElementById('range-warn');
  warn.textContent = '';
  if (params.min_color_temp > params.max_color_temp){
    // Swap to keep sane
    const tmp = params.min_color_temp;
    params.min_color_temp = params.max_color_temp;
    params.max_color_temp = tmp;
    warn.textContent = 'Note: Min CCT exceeded Max; values swapped.';
  }
}

// Plot
function plot(x, cct, bri){
  const cctSegs = buildCCTColoredSegments(x, cct);

  // Legend proxies
  const cctLegend = {
    type:'scatter', mode:'lines', x:[null], y:[null], name:'CCT (K)',
    line:{width:4, color: cctToRGB((params.min_color_temp+params.max_color_temp)/2)},
    hoverinfo:'skip', yaxis:'y1', showlegend:true
  };
  const briTrace = {
    type:'scatter', mode:'lines', x:x, y:bri.map(v=>Math.round(v)), name:'Brightness (%)',
    yaxis:'y2', line:{width:3}, hovertemplate:'%{y:.0f}% at %{x:.1f}h<extra></extra>'
  };

  const data = [...cctSegs, cctLegend, briTrace];

  const yMin = Math.max(0, Math.min(params.min_color_temp, params.max_color_temp) - 200);
  const yMax = Math.max(params.min_color_temp, params.max_color_temp) + 200;

  Plotly.newPlot('plot', data, {
    title: 'Adaptive Lighting Curve',
    xaxis: {title:'Time of Day (hours)', range:[0,24], dtick:3},
    yaxis: {title:'Color Temperature (K)', range:[yMin, yMax], autorange:false, titlefont:{color:'#333'}, tickfont:{color:'#333'}},
    yaxis2: {title:'Brightness (%)', overlaying:'y', side:'right', range:[0,105], autorange:false},
    showlegend:true, legend:{x:0.02,y:0.98}, margin:{t:50}
  }, {responsive:true});
}

function draw(){
  enforceRanges();
  const {hours, ccts, bris} = compute();
  plot(hours, ccts, bris);
}

// Build slider UI
function makePanel(){
  const panel = document.getElementById('ctrl-params');
  sliders.forEach(([key, min, val, max, step, label]) => {
    const lab = document.createElement('label'); lab.textContent = label;
    const rng = document.createElement('input');
    rng.type='range'; rng.min=min; rng.max=max; rng.step=step; rng.value=val;
    const out = document.createElement('span'); out.textContent = val;
    rng.oninput = e => { params[key] = parseFloat(e.target.value); out.textContent = e.target.value; draw(); };
    panel.append(lab, rng, out);
    params[key] = val;
  });
}

// Init
makePanel();
// First draw
draw();
</script>
</body>
</html>
