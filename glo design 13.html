<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Glo designer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
  :root{
    --bg:#121212; --panel:#1e1e1e; --muted:#9aa0a6; --fg:#ffffff; --grid:#444;
    --accent:#1e90ff; --btn:#2a2a2a; --btnBorder:#444;
    --nowBlue:#66b8ff;
  }
  html,body { height:100%; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    margin: 1.5rem; background: var(--bg); color: var(--fg);
  }
  .container {
    max-width: 1200px; margin: 0 auto; background: var(--panel);
    padding: 2rem; border-radius: 12px; box-shadow: 0 2px 12px rgba(0,0,0,.35);
  }
  h2 { margin: 0 0 1rem; color: #e0e0e0; }
  .stage { margin: 1.25rem 0 1rem; }
  #plot { touch-action: none; height: 460px; }
  .dragging #plot { cursor: ew-resize !important; }

  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  .section { border: 1px solid #2a2a2a; border-radius: 10px; padding: 14px; background: #1a1a1a; }
  .section-head{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
  .section-title{ font-size:1.0rem; font-weight:900; text-transform:uppercase; letter-spacing:.03em; color: var(--muted); }

  .group-title { 
    font-size: 1.05rem; font-weight: 800; color: var(--muted); 
    margin: 6px 0 8px; letter-spacing: .02em;
    display:flex; align-items:center; justify-content:space-between;
  }

  .controls-row {
    display: grid; grid-template-columns: 160px 1fr 110px; gap: 8px; align-items: center; margin: 8px 0;
  }
  .controls-wide {
    display: grid; grid-template-columns: 160px 1fr 90px; gap: 8px; align-items: center; margin: 10px 0;
  }
  label { font-size: .9rem; color: var(--muted); font-weight: 800; }
  .label-reset{ cursor:pointer; text-decoration: underline dotted; color: var(--muted); }
  .label-reset:hover{ filter:brightness(1.12); }
  .value { font-variant-numeric: tabular-nums; text-align: right; color: #c9cfd6; font-weight: 700; }

  input[type=range] { width: 100%; accent-color: var(--accent); }
  input[type=text], select {
    width: 100%; padding: 6px 8px; border: 1px solid var(--btnBorder);
    border-radius: 6px; background: var(--btn); color: #fff;
  }
  input[type=checkbox] { accent-color: var(--accent); }

  .dual-range { position: relative; display:flex; align-items: center; gap: 8px; width:100%; }
  .dual-track { position: relative; flex:1; height: 6px; background: var(--grid); border-radius: 3px; }
  .dual-range input[type=range]{ position:absolute; width:100%; margin:0; background:transparent; -webkit-appearance:none; appearance:none; height:6px; top:0; }
  .dual-range input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; width:16px; height:16px; background: var(--accent); border-radius:50%; cursor:pointer; position:relative; z-index:2; }
  .dual-range input[type=range]::-moz-range-thumb{ width:16px; height:16px; background: var(--accent); border-radius:50%; cursor:pointer; position:relative; z-index:2; }
  .dual-range input[id$="-min"]{ z-index:2; }
  .dual-range input[id$="-max"]{ z-index:1; }
  .fill { position:absolute; top:0; height:6px; background: var(--accent); border-radius:3px; z-index:0; }
  .label-chip{ font-size:.9rem; color:#c9cfd6; width:68px; text-align:right; font-variant-numeric: tabular-nums; }

  .btn { border:1px solid var(--btnBorder); background: var(--btn); color:#c8c8c8; padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:800; font-size:.9rem; }
  .btn:hover { filter: brightness(1.1); }

  .big-title { font-size: 1.15rem; font-weight: 900; margin: 1.25rem 0 .5rem; color: var(--muted); text-transform: uppercase; letter-spacing: .03em; }
  .warn { color:#ff6b6b; font-size:.9rem; margin-top:6px; }

  /* Control bar (left/right buttons + center steps) */
  .control-bar{
    display:flex; align-items:center; gap:12px; justify-content:space-between; flex-wrap:wrap;
  }
  .ctrl-side{ display:flex; align-items:center; gap:10px; }
  .delta{ color:#c9cfd6; font-variant-numeric: tabular-nums; opacity:.9; }
  .ctrl-center{ display:flex; align-items:center; gap:8px; }
  .num { width:80px; padding:6px 8px; border:1px solid var(--btnBorder); border-radius:6px; background:var(--btn); color:#fff; }

  /* Grey-out when mirrored */
  .is-locked { opacity: .5; }
  .mirror-slot { display:flex; align-items:center; gap:6px; }
  .mirror-slot label { cursor:pointer; text-transform: lowercase; }
</style>
</head>
<body>
<div class="container">
  <h2>Glo designer</h2>
  <div id="plot" class="stage"></div>

  <!-- Control bar ABOVE parameters -->
  <div class="section">
    <div class="section-head">
      <div class="section-title">Control</div>
    </div>
    <div class="control-bar" id="control-bar">
      <div id="left-side" class="ctrl-side">
        <button id="left-btn" class="btn">Dim</button>
        <span id="left-delta" class="delta">—</span>
      </div>
      <div class="ctrl-center">
        <label>Steps</label>
        <input id="step-count" class="num" type="number" value="15" min="1" max="500" step="1" />
      </div>
      <div id="right-side" class="ctrl-side">
        <span id="right-delta" class="delta">—</span>
        <button id="right-btn" class="btn">Brighten</button>
      </div>
    </div>
  </div>

  <div class="grid-2">
    <!-- Morning -->
    <div class="section">
      <div class="section-head">
        <div class="section-title">Morning</div>
        <button id="reset-morning" class="btn">Reset</button>
      </div>
      <div class="group-title">Brightness</div>
      <div id="morning-bri"></div>
      <div id="morning-cct-title" class="group-title" style="margin-top:12px;">
        <span>Color Temperature</span>
        <span class="mirror-slot" id="mirror-slot-up"></span>
      </div>
      <div id="morning-cct"></div>
    </div>

    <!-- Evening -->
    <div class="section">
      <div class="section-head">
        <div class="section-title">Evening</div>
        <button id="reset-evening" class="btn">Reset</button>
      </div>
      <div class="group-title">Brightness</div>
      <div id="evening-bri"></div>
      <div id="evening-cct-title" class="group-title" style="margin-top:12px;">
        <span>Color Temperature</span>
        <span class="mirror-slot" id="mirror-slot-dn"></span>
      </div>
      <div id="evening-cct"></div>
    </div>
  </div>

  <div class="big-title">Ranges</div>
  <div class="section">
    <div class="controls-wide">
      <label>Brightness (min–max)</label>
      <div class="dual-range">
        <span id="min-intensity-value" class="label-chip">1</span>
        <div class="dual-track">
          <input type="range" id="min-intensity" min="0" max="100" step="1" value="1">
          <input type="range" id="max-intensity" min="0" max="100" step="1" value="100">
          <div class="fill" id="intensity-fill"></div>
        </div>
        <span id="max-intensity-value" class="label-chip">100</span>
      </div>
    </div>
    <div class="controls-wide">
      <label>Color Temperature (K, min–max)</label>
      <div class="dual-range">
        <span id="min-temp-value" class="label-chip">500</span>
        <div class="dual-track">
          <input type="range" id="min-temp" min="500" max="6500" step="50" value="500">
          <input type="range" id="max-temp" min="500" max="6500" step="50" value="6500">
          <div class="fill" id="temp-fill"></div>
        </div>
        <span id="max-temp-value" class="label-chip">6500</span>
      </div>
    </div>
    <div id="range-warn" class="warn"></div>
  </div>

  <div class="big-title">Sun Position</div>
  <div class="section" id="sun-position"></div>

  <div class="section" style="display:flex; justify-content:flex-end;">
    <button id="reset-all" class="btn">Reset All</button>
  </div>
</div>

<script>
/* =========================
   Globals & state
========================= */
let plotDivRef = null;
let listenersBound = false;
let rafId = 0, lastClientX = null;
let setCursorRef = function(xh){};

/* Global “plot arc” only for interpolation in tooltips/preview (sorted by hour) */
let arc = { hours:[], bris:[], ccts:[] };

/* Half-day arc caches for stepping in solar-path order */
let morningArc = null, eveningArc = null;

const SAMPLE_STEP = 0.1;
const SOLAR_LABEL_SIZE = 10;

const W_B = 1.0;   // brightness weight
const W_C = 0.6;   // color (mired) weight

let selectedHour = (new Date().getHours() + new Date().getMinutes()/60);

/* draw suppression (for mirrored updates) */
let _suppressDrawDepth = 0;
function withSuppressedDraw(fn){ _suppressDrawDepth++; try{ fn(); } finally { _suppressDrawDepth--; } }

/* =========================
   Defaults & Parameters
========================= */
const defaults = {
  min_color_temp: 500, max_color_temp: 6500,
  min_brightness: 1,   max_brightness: 100,

  mid_bri_up: 6.0, steep_bri_up: 1.0, decay_bri_up: 0.02, gain_bri_up: 1.0, offset_bri_up: 0,
  mid_cct_up: 6.0, steep_cct_up: 1.0, decay_cct_up: 0.02, gain_cct_up: 1.0, offset_cct_up: 0,

  mid_bri_dn: 6.0, steep_bri_dn: 1.0, decay_bri_dn: 0.02, gain_bri_dn: 1.0, offset_bri_dn: 0,
  mid_cct_dn: 6.0, steep_cct_dn: 1.0, decay_cct_dn: 0.02, gain_cct_dn: 1.0, offset_cct_dn: 0,

  /* mirror flags default ON */
  match_cct_up: true,
  match_cct_dn: true,

  month: new Date().getMonth() + 1,
  latitude: 35.0, longitude: -78.6, timezone: 'US/Eastern',
  use12Hour: true
};
const params = JSON.parse(JSON.stringify(defaults));

/* key groups */
const BRIGHT_UP = ['mid_bri_up','steep_bri_up','decay_bri_up','gain_bri_up','offset_bri_up'];
const CCT_UP    = ['mid_cct_up','steep_cct_up','decay_cct_up','gain_cct_up','offset_cct_up'];
const BRIGHT_DN = ['mid_bri_dn','steep_bri_dn','decay_bri_dn','gain_bri_dn','offset_bri_dn'];
const CCT_DN    = ['mid_cct_dn','steep_cct_dn','decay_cct_dn','gain_cct_dn','offset_cct_dn'];

/* =========================
   Utilities
========================= */
const TZ_OPTIONS = [
  {id:'US/Eastern',label:'US/Eastern'},{id:'US/Central',label:'US/Central'},
  {id:'US/Mountain',label:'US/Mountain'},{id:'US/Pacific',label:'US/Pacific'},
  {id:'US/Alaska',label:'US/Alaska'},{id:'US/Arizona',label:'US/Arizona (no DST)'},
  {id:'US/Hawaii',label:'US/Hawaii (no DST)'}
];
const MONTHS = ['January','February','March','April','May','June','July','August','September','October','November','December'];

function utcOffsetFor(zone, month){
  const dst = (zone!=='US/Arizona' && zone!=='US/Hawaii') && (month>=3 && month<=10);
  switch(zone){
    case 'US/Eastern': return dst ? -4 : -5;
    case 'US/Central': return dst ? -5 : -6;
    case 'US/Mountain': return dst ? -6 : -7;
    case 'US/Pacific': return dst ? -7 : -8;
    case 'US/Alaska': return dst ? -8 : -9;
    case 'US/Arizona': return -7;
    case 'US/Hawaii': return -10;
    default: return -5;
  }
}
function formatTime(hour, use12Hour){
  let total=Math.round(hour*60); let h=Math.floor(total/60), m=total%60;
  if(!use12Hour) return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
  const ampm=h<12?'AM':'PM'; h=h%12; if(h===0) h=12; return `${h}:${String(m).padStart(2,'0')}${ampm}`;
}
const CUM_DAYS=[0,31,59,90,120,151,181,212,243,273,304,334];
const deg2rad=d=>d*Math.PI/180, rad2deg=r=>r*180/Math.PI, doyForMonthMid=m=>CUM_DAYS[m-1]+15;
function solarDeclinationRad(doy){ const g=2*Math.PI/365*(doy-1);
  return 0.006918-0.399912*Math.cos(g)+0.070257*Math.sin(g)-0.006758*Math.cos(2*g)+0.000907*Math.sin(2*g)-0.002697*Math.cos(3*g)+0.00148*Math.sin(3*g);}
function equationOfTimeMinutes(doy){ const B=2*Math.PI*(doy-81)/364;
  return 9.87*Math.sin(2*B)-7.53*Math.cos(B)-1.5*Math.sin(B); }
function localSolarTimeHours(clockHour,utcOffset,longitude,doy){
  const LSTM=15*utcOffset; const TC=equationOfTimeMinutes(doy)+4*(longitude-LSTM); return clockHour+TC/60;
}
function hourAngleRad(clockHour,utcOffset,longitude,doy){ const LST=localSolarTimeHours(clockHour,utcOffset,longitude,doy); return deg2rad(15*(LST-12)); }
function sunElevationDeg(clockHour,month,latDeg,lonDeg,tz){ const doy=doyForMonthMid(month); const utc=utcOffsetFor(tz,month);
  const phi=deg2rad(latDeg), delta=solarDeclinationRad(doy), H=hourAngleRad(clockHour,utc,lonDeg,doy);
  return rad2deg(Math.asin(Math.sin(phi)*Math.sin(delta)+Math.cos(phi)*Math.cos(delta)*Math.cos(H)));
}
function calculateSunTimes(month, lat, lon, tz){
  const doy=doyForMonthMid(month), phi=deg2rad(lat), delta=solarDeclinationRad(doy);
  const cosH=-Math.tan(phi)*Math.tan(delta), utc=utcOffsetFor(tz,month);
  const LSTM=15*utc; const TC=equationOfTimeMinutes(doy)+4*(lon-LSTM);
  const solarNoon=12-TC/60, solarMidnight=(solarNoon+12)%24;
  if(cosH>1) return {sunrise:null,sunset:null,solarNoon,solarMidnight};
  if(cosH<-1) return {sunrise:0,sunset:24,solarNoon,solarMidnight};
  const H=rad2deg(Math.acos(cosH));
  return {sunrise:(12-H/15)-TC/60, sunset:(12+H/15)-TC/60, solarNoon, solarMidnight};
}
function clearSkyGHI(hour,month,lat,lon,tz){
  const alt=sunElevationDeg(hour,month,lat,lon,tz); if(alt<=0) return null;
  const cosZ=Math.sin(deg2rad(alt)); return 1098*cosZ*Math.exp(-0.059/cosZ)*300/1098;
}
function cctToRGB(k){
  k=Math.max(500,Math.min(6500,k)); const t=k/100; let r,g,b;
  if(t<=66) r=255; else r=329.698727446*Math.pow(t-60,-0.1332047592);
  if(t<=66) g=99.4708025861*Math.log(t)-161.1195681661; else g=288.1221695283*Math.pow(t-60,-0.0755148492);
  if(t>=66) b=255; else if(t<=19) b=0; else b=138.5177312231*Math.log(t-10)-305.0447927307;
  const clamp=v=>Math.max(0,Math.min(255,Math.round(v))); return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
}
function parseRGB(str){ const m=str.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/i); return m?[+m[1],+m[2],+m[3]]:[255,255,255]; }
function blend(a,b,t){ return [Math.round(a[0]*(1-t)+b[0]*t), Math.round(a[1]*(1-t)+b[1]*t), Math.round(a[2]*(1-t)+b[2]*t)]; }
function lineColorForCCT(k){
  const base=parseRGB(cctToRGB(k));
  if(k<=6000) return `rgb(${base[0]},${base[1]},${base[2]})`;
  const f=Math.min(1,Math.max(0,(k-6000)/500));
  const blue=[150,200,255]; const t=0.6*f;
  const [r,g,b]=blend(base,blue,t); return `rgb(${r},${g},${b})`;
}
function hourDistance(a, b){
  let d = Math.abs(a - b);
  return d > 12 ? 24 - d : d;
}


/* =========================
   Curve math (half-day)
========================= */
const logisticUp=(t,m,k)=>1/(1+Math.exp(-k*(t-m)));
const decayAroundNoon=(t,alpha)=>Math.exp(-alpha*Math.pow(t-12,2));

function mapMorning(t,{m,k,alpha,gain,offset,outMin,outMax}){
  const base=logisticUp(t,m,k)*decayAroundNoon(t,alpha);
  const scaled=Math.max(0,Math.min(1,base*gain));
  let y=outMin+(outMax-outMin)*scaled; y+=offset; return y;
}
function mapEvening(t,{m,k,alpha,gain,offset,outMin,outMax}){
  const te=t-12;
  const base=(1-logisticUp(te,m,k))*decayAroundNoon(t,alpha);
  const scaled=Math.max(0,Math.min(1,base*gain));
  let y=outMin+(outMax-outMin)*scaled; y+=offset; return y;
}

/* =========================
   Compute series (returns halves)
========================= */
function compute(){
  const {solarNoon, solarMidnight}=calculateSunTimes(params.month,params.latitude,params.longitude,params.timezone);

  const briBounds=[params.min_brightness, params.max_brightness];
  const cctBounds=[params.min_color_temp, params.max_color_temp];

  // MORNING path: solarMidnight → solarNoon
  const mHours=[], mBri=[], mCct=[], mSun=[];
  for(let t=0; t<12; t+=SAMPLE_STEP){
    const hour=(solarMidnight + (t/12)*((solarNoon - solarMidnight + 24)%24))%24;
    mHours.push(hour);
    let vb=mapMorning(t,{m:params.mid_bri_up,k:params.steep_bri_up,alpha:params.decay_bri_up,gain:params.gain_bri_up,offset:params.offset_bri_up,outMin:briBounds[0],outMax:briBounds[1]});
    vb=Math.max(0,Math.min(100,vb)); mBri.push(vb);
    let vc=mapMorning(t,{m:params.mid_cct_up,k:params.steep_cct_up,alpha:params.decay_cct_up,gain:params.gain_cct_up,offset:params.offset_cct_up,outMin:cctBounds[0],outMax:cctBounds[1]});
    vc=Math.max(500,Math.min(6500,vc)); mCct.push(vc);
    mSun.push(clearSkyGHI(hour,params.month,params.latitude,params.longitude,params.timezone));
  }
  { // exact noon
    const hour=solarNoon%24; mHours.push(hour);
    let vb=mapMorning(12,{m:params.mid_bri_up,k:params.steep_bri_up,alpha:params.decay_bri_up,gain:params.gain_bri_up,offset:params.offset_bri_up,outMin:briBounds[0],outMax:briBounds[1]});
    vb=Math.max(0,Math.min(100,vb)); mBri.push(vb);
    let vc=mapMorning(12,{m:params.mid_cct_up,k:params.steep_cct_up,alpha:params.decay_cct_up,gain:params.gain_cct_up,offset:params.offset_cct_up,outMin:cctBounds[0],outMax:cctBounds[1]});
    vc=Math.max(500,Math.min(6500,vc)); mCct.push(vc);
    mSun.push(clearSkyGHI(hour,params.month,params.latitude,params.longitude,params.timezone));
  }

  // EVENING path: solarNoon → (wrap) → solarMidnight
  const eHours=[], eBri=[], eCct=[], eSun=[];

  // *** include exact solar noon as the first evening sample (hard stop target) ***
  {
    const hour = solarNoon % 24;
    eHours.push(hour);
    let vb = mapEvening(12, { m: params.mid_bri_dn, k: params.steep_bri_dn, alpha: params.decay_bri_dn,
                              gain: params.gain_bri_dn, offset: params.offset_bri_dn,
                              outMin: briBounds[0], outMax: briBounds[1] });
    vb = Math.max(0, Math.min(100, vb)); eBri.push(vb);

    let vc = mapEvening(12, { m: params.mid_cct_dn, k: params.steep_cct_dn, alpha: params.decay_cct_dn,
                              gain: params.gain_cct_dn, offset: params.offset_cct_dn,
                              outMin: cctBounds[0], outMax: cctBounds[1] });
    vc = Math.max(500, Math.min(6500, vc)); eCct.push(vc);

    eSun.push(clearSkyGHI(hour, params.month, params.latitude, params.longitude, params.timezone));
  }

  // proceed just *after* noon through to midnight (includes exact midnight)
  for(let t=12+SAMPLE_STEP; t<=24.0001; t+=SAMPLE_STEP){
    const hour=(solarNoon + ((t-12)/12)*((solarMidnight - solarNoon + 24)%24))%24;
    eHours.push(hour);
    let vb=mapEvening(t,{m:params.mid_bri_dn,k:params.steep_bri_dn,alpha:params.decay_bri_dn,gain:params.gain_bri_dn,offset:params.offset_bri_dn,outMin:briBounds[0],outMax:briBounds[1]});
    vb=Math.max(0,Math.min(100,vb)); eBri.push(vb);
    let vc=mapEvening(t,{m:params.mid_cct_dn,k:params.steep_cct_dn,alpha:params.decay_cct_dn,gain:params.gain_cct_dn,offset:params.offset_cct_dn,outMin:cctBounds[0],outMax:cctBounds[1]});
    vc=Math.max(500,Math.min(6500,vc)); eCct.push(vc);
    eSun.push(clearSkyGHI(hour,params.month,params.latitude,params.longitude,params.timezone));
  }

  // For plotting, keep a sorted-by-hour view
  const hours=[...mHours,...eHours], bri=[...mBri,...eBri], cct=[...mCct,...eCct], sun=[...mSun,...eSun];
  const idx = hours.map((_,i)=>i).sort((a,b)=>hours[a]-hours[b]);
  const H=idx.map(i=>hours[i]), B=idx.map(i=>bri[i]), C=idx.map(i=>cct[i]), S=idx.map(i=>sun[i]);

  return {
    hours:H, bris:B, ccts:C, sunPower:S,
    morn:{hours:mHours, bris:mBri, ccts:mCct},
    eve: {hours:eHours, bris:eBri, ccts:eCct}
  };
}

/* Interp at arbitrary hour (sorted-by-hour arrays) */
function interpAtHour(hours, arr, h){
  if(h<=hours[0]) return arr[0];
  for(let i=1;i<hours.length;i++){
    if(h<=hours[i]){
      const h0=hours[i-1], h1=hours[i], t=(h-h0)/(h1-h0);
      return arr[i-1] + t*(arr[i]-arr[i-1]);
    }
  }
  return arr[arr.length-1];
}

/* =========================
   Half-arc builders (solar-path order)
========================= */
function buildHalfArc(half){
  const bmin = params.min_brightness, bmax = params.max_brightness;
  const toMired = k => 1e6 / k;
  const cminM = toMired(params.max_color_temp);
  const cmaxM = toMired(params.min_color_temp);

  const H = half.hours, Braw = half.bris, Craw = half.ccts;

  const Bn = Braw.map(b => (b - bmin) / Math.max(1e-9, (bmax - bmin)));
  const Cmir = Craw.map(k => toMired(k));
  const Cn = Cmir.map(m => (m - cminM) / Math.max(1e-9, (cmaxM - cminM)));

  const S=[0];
  for(let i=1;i<H.length;i++){
    const dB = Bn[i]-Bn[i-1];
    const dC = Cn[i]-Cn[i-1];
    const dS = Math.sqrt(W_B*dB*dB + W_C*dC*dC);
    S.push(S[i-1] + dS);
  }
  const total = S[S.length-1];

  function sAtHour(h){
    for(let i=1;i<H.length;i++){
      const h0=H[i-1], h1=H[i];
      let span = h1 - h0;
      if (span < -12) span += 24;
      if (span >  12) span -= 24;

      let dh = h - h0;
      if (dh < -12) dh += 24;
      if (dh >  12) dh -= 24;

      const between = span>=0 ? (dh>=0 && dh<=span) : (dh<=0 && dh>=span);
      if (between){
        const t = (span===0) ? 0 : (dh/span);
        return S[i-1] + t*(S[i]-S[i-1]);
      }
    }
    const dStart = Math.min(Math.abs(h-H[0]), 24-Math.abs(h-H[0]));
    const dEnd   = Math.min(Math.abs(h-H[H.length-1]), 24-Math.abs(h-H[H.length-1]));
    return (dStart<=dEnd)? 0 : total;
  }

  function hourAtS(s){
    if (s<=0) return H[0];
    if (s>=total) return H[H.length-1];
    for(let i=1;i<S.length;i++){
      if (s <= S[i]){
        const t=(s-S[i-1])/Math.max(1e-9,(S[i]-S[i-1]));
        let h0=H[i-1], h1=H[i];
        let span = h1 - h0;
        if (span < -12) span += 24;
        if (span >  12) span -= 24;
        let h = h0 + t*span;
        if (h<0) h+=24;
        if (h>=24) h-=24;
        return h;
      }
    }
    return H[H.length-1];
  }

  return { hours:H, bris:Braw, ccts:Craw, S, total, sAtHour, hourAtS };
}

function rebuildHalfArcCaches(morn, eve){
  morningArc = buildHalfArc(morn);
  eveningArc = buildHalfArc(eve);
}

/* =========================
   Dim/Brighten helpers
========================= */
function meetsConstraint(action, hTarget, b0, k0){
  const b1 = interpAtHour(arc.hours, arc.bris, hTarget);
  const k1 = interpAtHour(arc.hours, arc.ccts, hTarget);
  const m0 = 1e6 / k0, m1 = 1e6 / k1; // mireds
  const EPS_B = 0.05;   // brightness tolerance in % points
  const EPS_M = 1e-4;   // tiny color tolerance
  if (action === 'dim') {      // dimmer AND warmer
    return (b1 <= b0 + EPS_B) && (m1 >= m0 - EPS_M);
  } else {                     // brighten: brighter AND cooler
    return (b1 >= b0 - EPS_B) && (m1 <= m0 + EPS_M);
  }
}

function currentHalf(){
  const {solarNoon, solarMidnight} = calculateSunTimes(params.month,params.latitude,params.longitude,params.timezone);
  const h = selectedHour;
  return (h >= solarNoon) || (h < solarMidnight) ? 'evening' : 'morning';
}

function computeActionTarget(action){
  if(!morningArc || !eveningArc) return null;

  const half = currentHalf();
  const arcRef = (half==='morning') ? morningArc : eveningArc;

  const stepCount = Math.max(1, Math.min(500, parseInt(document.getElementById('step-count')?.value || '15',10)));
  const stepS = Math.max(1e-9, arcRef.total / stepCount);

  // Direction:
  // Morning (solarMidnight→solarNoon): brighten=+step, dim=-step
  // Evening (solarNoon→solarMidnight): brighten=-step, dim=+step
  const sDir = (half==='morning')
    ? (action==='brighten' ? +1 : -1)
    : (action==='brighten' ? -1 : +1);

  const sNow = arcRef.sAtHour(selectedHour);
  let sTarget = Math.max(0, Math.min(arcRef.total, sNow + sDir*stepS));
  let hTarget = arcRef.hourAtS(sTarget);

  const b0 = interpAtHour(arc.hours, arc.bris, selectedHour);
  const k0 = interpAtHour(arc.hours, arc.ccts, selectedHour);

  if (!meetsConstraint(action, hTarget, b0, k0)) {
    const delta = arcRef.total / 400;
    let s = sTarget, found = false;
    for (let i=0; i<800; i++) {
      s = Math.max(0, Math.min(arcRef.total, s + sDir * delta));
      hTarget = arcRef.hourAtS(s);
      if (meetsConstraint(action, hTarget, b0, k0)) { found = true; break; }
      if (s === 0 || s === arcRef.total) break;
    }
    if (!found) return null;
  }
    // Hard-stop on boundaries (no tiny overshoot)
  {
    const { solarNoon, solarMidnight } = calculateSunTimes(params.month, params.latitude, params.longitude, params.timezone);
    const NOON = (solarNoon % 24), MIDNIGHT = (solarMidnight % 24), EPSH = 1e-3;
    if (hourDistance(hTarget, NOON) < EPSH)      hTarget = NOON;
    if (hourDistance(hTarget, MIDNIGHT) < EPSH)  hTarget = MIDNIGHT;
  }
  return hTarget;
}

function stepArc(action){
  const hTarget = computeActionTarget(action);
  if (hTarget==null) return;
  setCursorRef(hTarget);
}

/* ========= Preview & layout of the Control bar ========= */
function fmtSigned(n, unit){
  const sign = n>0?'+':(n<0?'−':'±');
  const abs = Math.abs(Math.round(n));
  return `${sign}${abs}${unit}`;
}
function fmtTimeDelta(hNew, hOld){
  const minutes = Math.round((hNew - hOld)*60);
  const sign = minutes>0?'+':(minutes<0?'−':'±');
  const a = Math.abs(minutes);
  const hh = Math.floor(a/60), mm = a%60;
  if (hh>0) return `${sign}${hh}h ${mm}m`;
  return `${sign}${mm}m`;
}
function updatePreviewDeltas(){
  const leftBtn = document.getElementById('left-btn');
  const rightBtn = document.getElementById('right-btn');
  const leftDelta = document.getElementById('left-delta');
  const rightDelta = document.getElementById('right-delta');

  const half = currentHalf();
  if (half === 'morning'){
    leftBtn.textContent = 'Dim';
    leftBtn.onclick = ()=> stepArc('dim');
    rightBtn.textContent = 'Brighten';
    rightBtn.onclick = ()=> stepArc('brighten');
  } else {
    leftBtn.textContent = 'Brighten';
    leftBtn.onclick = ()=> stepArc('brighten');
    rightBtn.textContent = 'Dim';
    rightBtn.onclick = ()=> stepArc('dim');
  }

  const b0 = interpAtHour(arc.hours, arc.bris, selectedHour);
  const k0 = interpAtHour(arc.hours, arc.ccts, selectedHour);

  function preview(action){
    const hT = computeActionTarget(action);
    if (hT==null) return 'no change';
    const b1 = interpAtHour(arc.hours, arc.bris, hT);
    const k1 = interpAtHour(arc.hours, arc.ccts, hT);
    const dt = fmtTimeDelta(hT, selectedHour);
    const db = fmtSigned(b1 - b0, '%');
    const dk = fmtSigned(k1 - k0, 'K');
    return `${dt}, ${db}, ${dk}`;
  }

  if (half === 'morning'){
    leftDelta.textContent  = preview('dim');
    rightDelta.textContent = preview('brighten');
  } else {
    leftDelta.textContent  = preview('brighten');
    rightDelta.textContent = preview('dim');
  }
}

/* =========================
   Plot (colored segments; single tooltip)
========================= */
function buildHomeGloColored(x,bri,cct){
  const segs=[];
  for(let i=1;i<x.length;i++){
    if(x[i]-x[i-1] > 1.5) continue;
    const midC=0.5*(cct[i-1]+cct[i]);
    const color=lineColorForCCT(midC);
    segs.push({type:'scatter',mode:'lines',x:[x[i-1],x[i]],y:[bri[i-1],bri[i]],
               line:{width:4,color},name:'Home Glo',yaxis:'y',hoverinfo:'skip',showlegend:false});
  }
  return segs;
}
function buildSunColored(x,sun){
  const segs=[];
  for(let i=1;i<x.length;i++){
    if(sun[i-1]==null || sun[i]==null) continue;
    if(x[i]-x[i-1] > 1.5) continue;
    const mid=0.5*(sun[i-1]+sun[i]);
    let r=255,g=255,b=255;
    if(mid<=2){ r=255; g=255; b=200; }
    else if(mid>200){ const t=(mid-200)/100; r=Math.round(255-55*t); g=Math.round(255-55*t); b=255; }
    else { const t=(mid-2)/198; r=255; g=255; b=Math.round(200+t*(255-200)); }
    segs.push({type:'scatter',mode:'lines',x:[x[i-1],x[i]],y:[sun[i-1],sun[i]],
               line:{width:1,color:`rgb(${r},${g},${b})`,dash:'dot'},name:'sunlight',yaxis:'y',hoverinfo:'skip',showlegend:false});
  }
  return segs;
}

/* =========================
   Render & interactions
========================= */
function renderPlot(x,cct,bri,sunPower, morn, eve){
  // Build half-arc caches for stepping
  rebuildHalfArcCaches(morn, eve);

  // Set global arc for interpolation & constraints (sorted-by-hour arrays)
  arc.hours = x.slice();
  arc.bris  = bri.map(v=>Math.round(v));
  arc.ccts  = cct.slice();

  const segs=buildHomeGloColored(x,bri.map(v=>Math.round(v)),cct);
  const sunSegs=buildSunColored(x,sunPower);

  const homeLegend={type:'scatter',mode:'lines',x:[null],y:[null],name:'Glo',
    line:{width:4,color:'#fff'},hoverinfo:'skip',showlegend:true,yaxis:'y'};
  const sunLegend={type:'scatter',mode:'lines',x:[null],y:[null],name:'sunlight',
    line:{width:1,color:'#fff',dash:'dot'},hoverinfo:'skip',showlegend:true,yaxis:'y'};

  const hoverProxy={type:'scatter',mode:'lines',x:x,y:bri,name:'Home Glo (hover)',
    line:{width:14,color:'rgba(0,0,0,0)'},
    hovertemplate: '%{text}<br>Home Glo %{y:.0f}%<br>color temperature %{customdata:.0f} K<extra></extra>',
    text:x.map(h=>formatTime(h,params.use12Hour)), customdata:cct, yaxis:'y', showlegend:false};

  const now=new Date(); const nowHour=now.getHours()+now.getMinutes()/60;
  const nowBri=interpAtHour(x,bri,nowHour); const nowCCT=interpAtHour(x,cct,nowHour);
  const nowOutline = (getComputedStyle(document.documentElement).getPropertyValue('--nowBlue') || '#66b8ff').trim();
  const currentTimeMarker={type:'scatter',mode:'markers', x:[nowHour], y:[nowBri], name:'now marker',
    marker:{size:10,color:cctToRGB(nowCCT), line:{width:2,color: nowOutline}}, hoverinfo:'skip', showlegend:false};

  const {sunrise,sunset,solarNoon,solarMidnight}=calculateSunTimes(params.month,params.latitude,params.longitude,params.timezone);

  const annotations=[];
  const annotate=(xpos,label,color)=>{ if(xpos==null||xpos<0||xpos>24) return;
    annotations.push({x:xpos,y:-0.15,yref:'paper',text:`${label}<br>${formatTime(xpos,params.use12Hour)}`,
      showarrow:false,font:{size:SOLAR_LABEL_SIZE,color:color||'#fff'},xanchor:'center',yanchor:'top', cliponaxis:false}); };
  annotate(sunrise,'sunrise');
  annotate(sunset,'sunset');
  annotate(solarNoon,'solar noon');
  annotate(solarMidnight,'solar midnight');

  annotations.push({
    x: nowHour, y: -0.10, yref: 'paper',
    text: `now ${formatTime(nowHour, params.use12Hour).toLowerCase()}`,
    showarrow: false,
    font: { size: SOLAR_LABEL_SIZE, color: nowOutline, weight: 800 },
    xanchor: 'center', yanchor: 'top',
    cliponaxis: false
  });

  const selBri = interpAtHour(x,bri,selectedHour);
  const selCCT = interpAtHour(x,cct,selectedHour);

  const selectionMarker = {
    type:'scatter', mode:'markers', x:[selectedHour], y:[selBri],
    name:'selected', marker:{ size:12, color:cctToRGB(selCCT), line:{width:2,color:'#ffffff'} },
    hoverinfo:'skip', showlegend:false
  };

  const cursorShape = {
    type:'line', xref:'x', x0:selectedHour, x1:selectedHour,
    yref:'paper', y0:0, y1:1, line:{color:'#1e90ff', width:2}
  };

  const data=[...segs, homeLegend, sunLegend, hoverProxy, ...sunSegs, currentTimeMarker, selectionMarker];

  const layout={
    dragmode: 'pan',
    hovermode: 'closest',
    xaxis:{ range:[0,24], tickmode:'array', tickvals:[0,3,6,9,12,15,18,21,24],
            ticktext: params.use12Hour? ['12am','3am','6am','9am','12pm','3pm','6pm','9pm','12am']
                                      : ['00:00','03:00','06:00','09:00','12:00','15:00','18:00','21:00','00:00'],
            tickfont:{color:'#fff'}, showgrid:true, gridcolor:'#444', fixedrange: true,
            minor:{ tickmode:'array', tickvals:Array.from({length:25},(_,i)=>i),
                    ticks:'outside', ticklen:4, tickcolor:'#444', showgrid:true, minor_gridcolor:'#333' } },
    yaxis:{ title:'brightness', range:[0,300], autorange:false, tickfont:{color:'#fff'}, fixedrange: true, showgrid:true, gridcolor:'#444' },
    showlegend:true, legend:{x:0.02,y:0.98, font:{color:'#fff'}, bgcolor:'rgba(0,0,0,.5)'},
    margin:{t:30,b:90},
    annotations:[
      ...annotations,
      {
        x: selectedHour, y: selBri,
        text: `${formatTime(selectedHour, params.use12Hour)}<br><b>${Math.round(selBri)}%</b> • ${Math.round(selCCT)} K`,
        showarrow: true, arrowhead: 4, arrowsize: 1, arrowwidth: 1, arrowcolor: 'rgba(200,200,200,0.8)',
        ax: 0, ay: -40,
        bgcolor: 'rgba(0,0,0,0.65)', bordercolor: 'rgba(150,150,150,0.6)', borderwidth: 1,
        font: {color:'#fff', size:12}
      }
    ],
    shapes:[cursorShape],
    paper_bgcolor:'#1e1e1e', plot_bgcolor:'#1e1e1e',
    uirevision: 'keep'
  };

  const config={responsive:true, editable:false, scrollZoom:false, doubleClick:false, displayModeBar:false};

  const clampX = (x)=> Math.max(0, Math.min(24, x));
  function setCursor(xh) {
    if(!plotDivRef) return;
    const xh2 = clampX(xh); selectedHour = xh2;
    const selBri2 = interpAtHour(x, bri, xh2);
    const selCCT2 = interpAtHour(x, cct, xh2);

    Plotly.relayout(plotDivRef, { 'shapes[0].x0': xh2, 'shapes[0].x1': xh2, 'shapes[0].y0': 0, 'shapes[0].y1': 1 });

    const selIdx = plotDivRef.data.findIndex(t => t && t.name === 'selected' && t.mode === 'markers');
    if (selIdx !== -1) {
      Plotly.restyle(plotDivRef, { x: [[xh2]], y: [[selBri2]], 'marker.color': [[cctToRGB(selCCT2)]] }, selIdx);
    }

    const annLen = (plotDivRef.layout.annotations || []).length;
    if (annLen > 0) {
      const annIndex = annLen - 1;
      const upd = {};
      upd[`annotations[${annIndex}].x`] = xh2;
      upd[`annotations[${annIndex}].y`] = selBri2;
      upd[`annotations[${annIndex}].text`] = `${formatTime(xh2, params.use12Hour)}<br><b>${Math.round(selBri2)}%</b> • ${Math.round(selCCT2)} K`;
      Plotly.relayout(plotDivRef, upd);
    }

    updatePreviewDeltas();
  }
  setCursorRef = setCursor;

  if (plotDivRef) {
    Plotly.react(plotDivRef, data, layout, config);
  } else {
    Plotly.newPlot('plot', data, layout, config).then(div => {
      plotDivRef = div;
      bindInteractionsOnce();
    });
  }
}

/* One-time pointer/click bindings + rAF throttle */
function bindInteractionsOnce(){
  if (listenersBound || !plotDivRef) return;

  const getPlotArea = () => plotDivRef.querySelector('.cartesianlayer .plot') || plotDivRef;

  const mapClientXToHour = (clientX) => {
    const rect = getPlotArea().getBoundingClientRect();
    const t = (clientX - rect.left) / rect.width;
    return Math.max(0, Math.min(24, 24 * t));
  };

  let dragging = false;

  const tick = () => {
    if (lastClientX == null) { rafId = 0; return; }
    setCursorRef(mapClientXToHour(lastClientX));
    rafId = 0;
  };

  const onPointerDown = (e) => {
    dragging = true;
    document.body.classList.add('dragging');
    lastClientX = e.clientX;
    if (!rafId) rafId = requestAnimationFrame(tick);
  };
  const onPointerMove = (e) => {
    if (!dragging) return;
    lastClientX = e.clientX;
    if (!rafId) rafId = requestAnimationFrame(tick);
  };
  const onPointerUp = () => {
    dragging = false;
    document.body.classList.remove('dragging');
    lastClientX = null;
  };
  const onClick = (e) => setCursorRef(mapClientXToHour(e.clientX));

  const area = plotDivRef;
  area.addEventListener('pointerdown', onPointerDown, { passive: true });
  window.addEventListener('pointermove', onPointerMove, { passive: true });
  window.addEventListener('pointerup', onPointerUp, { passive: true });
  area.addEventListener('click', onClick, { passive: true });

  plotDivRef.on('plotly_relayout', ev => {
    if (('xaxis.range[0]' in ev) || ('xaxis.range[1]' in ev) ||
        ('yaxis.range[0]' in ev) || ('yaxis.range[1]' in ev)) {
      Plotly.relayout(plotDivRef, { 'xaxis.range':[0,24], 'yaxis.range':[0,300] });
    }
  });

  const steps = document.getElementById('step-count');
  if (steps) steps.addEventListener('input', updatePreviewDeltas);

  listenersBound = true;
}

/* =========================
   UI (sliders & controls)
========================= */
const controls = {};

function updateMidpointLabels(){
  ['mid_bri_up','mid_cct_up','mid_bri_dn','mid_cct_dn'].forEach((key)=>{
    if (controls[key]) controls[key].dispatchEvent(new Event('input'));
  });
}

/* unified param update to support mirroring & single draw */
function updateParam(key, value){
  params[key] = value;

  // If brightness changed and mirror is ON, copy to CCT for same half
  if (/_bri_/.test(key)){
    const isMorning = /_up$/.test(key);
    const mirrorOn = isMorning ? params.match_cct_up : params.match_cct_dn;
    if (mirrorOn){
      const cKey = key.replace('_bri_', '_cct_');
      if (controls[cKey]){
        withSuppressedDraw(()=>{
          controls[cKey].value = String(value);
          controls[cKey].dispatchEvent(new Event('input'));
        });
      } else {
        params[cKey] = value;
      }
    }
  }

  if (_suppressDrawDepth===0) draw();
}

function addSliderRow(parent, {label, key, min, max, step, format, defaultValue}){
  const row=document.createElement('div'); row.className='controls-row';
  const lab=document.createElement('label'); lab.textContent=label; lab.className='label-reset'; lab.title='Click to reset';
  const input=document.createElement('input'); input.type='range'; input.min=min; input.max=max; input.step=step; input.value=params[key];
  const val=document.createElement('div'); val.className='value';

  const updateLabel = () => { val.textContent = format ? format(params[key]) : params[key]; };

  input.oninput = e => { const v=parseFloat(e.target.value); updateParam(key, v); updateLabel(); };
  lab.onclick = () => { const v = defaultValue; input.value=v; updateParam(key, v); updateLabel(); };

  updateLabel();
  row.append(lab,input,val);
  parent.appendChild(row);
  controls[key]=input;
}

function addRangesUI(){
  const minT=document.getElementById('min-temp'), maxT=document.getElementById('max-temp');
  const minI=document.getElementById('min-intensity'), maxI=document.getElementById('max-intensity');
  const tempFill=document.getElementById('temp-fill'), intFill=document.getElementById('intensity-fill');

  function updateTempFill(){
    const minVal=+minT.value, maxVal=+maxT.value;
    const left=((minVal-500)/(6500-500))*100, width=((maxVal-minVal)/(6500-500))*100;
    tempFill.style.left=`${left}%`; tempFill.style.width=`${width}%`;
  }
  function updateIntFill(){
    const minVal=+minI.value, maxVal=+maxI.value;
    const left=(minVal/100)*100, width=((maxVal-minVal)/100)*100;
    intFill.style.left=`${left}%`; intFill.style.width=`${width}%`;
  }
  const minTVal=document.getElementById('min-temp-value'), maxTVal=document.getElementById('max-temp-value');
  const minIVal=document.getElementById('min-intensity-value'), maxIVal=document.getElementById('max-intensity-value');

  function clampRanges(){
    const warn=document.getElementById('range-warn'); warn.textContent='';
    if(+minT.value > +maxT.value){ const t=minT.value; minT.value=maxT.value; maxT.value=t; warn.textContent='Note: min CCT exceeded max; swapped.'; }
    if(+minI.value > +maxI.value){ const t=minI.value; minI.value=maxI.value; maxI.value=t; warn.textContent+=' Note: min brightness exceeded max; swapped.'; }
    params.min_color_temp=+minT.value; params.max_color_temp=+maxT.value;
    params.min_brightness=+minI.value; params.max_brightness=+maxI.value;
    minTVal.textContent=params.min_color_temp; maxTVal.textContent=params.max_color_temp;
    minIVal.textContent=params.min_brightness; maxIVal.textContent=params.max_brightness;
    updateTempFill(); updateIntFill(); draw();
  }
  minT.oninput=clampRanges; maxT.oninput=clampRanges; minI.oninput=clampRanges; maxI.oninput=clampRanges;

  minT.value=params.min_color_temp; maxT.value=params.max_color_temp;
  minI.value=params.min_brightness; maxI.value=params.max_brightness;
  minTVal.textContent=params.min_color_temp; maxTVal.textContent=params.max_color_temp;
  minIVal.textContent=params.min_brightness; maxIVal.textContent=params.max_brightness;
  updateTempFill(); updateIntFill();

  controls.min_color_temp=minT; controls.max_color_temp=maxT;
  controls.min_brightness=minI; controls.max_brightness=maxI;
}

function addSunUI(){
  const wrap=document.getElementById('sun-position');
  wrap.innerHTML='';

  (()=>{ const row=document.createElement('div'); row.className='controls-row';
    const lab=document.createElement('label'); lab.textContent='Month'; lab.className='label-reset'; lab.title='Click to reset';
    const sel=document.createElement('select');
    MONTHS.forEach((name,idx)=>{ const o=document.createElement('option'); o.value=String(idx+1); o.textContent=name; if(idx+1===params.month) o.selected=true; sel.appendChild(o); });
    const val=document.createElement('div'); val.className='value'; val.textContent=MONTHS[params.month-1];
    sel.onchange=e=>{ params.month=+e.target.value; val.textContent=MONTHS[params.month-1]; draw(); updateMidpointLabels(); };
    lab.onclick=()=>{ params.month=defaults.month; sel.value=String(params.month); val.textContent=MONTHS[params.month-1]; draw(); updateMidpointLabels(); };
    row.append(lab,sel,val); wrap.appendChild(row); controls.month=sel; })();

  (()=>{ const row=document.createElement('div'); row.className='controls-row';
    const lab=document.createElement('label'); lab.textContent='latitude (°; N+, S-)'; lab.className='label-reset'; lab.title='Click to reset';
    const txt=document.createElement('input'); txt.type='text'; txt.value=params.latitude;
    const val=document.createElement('div'); val.className='value'; val.textContent=params.latitude;
    const commit=()=>{ const v=parseFloat(txt.value); if(!Number.isNaN(v)){ params.latitude=v; val.textContent=v; draw(); updateMidpointLabels(); } else { txt.value=params.latitude; } };
    txt.onblur=commit; txt.onkeydown=e=>{ if(e.key==='Enter') txt.blur(); };
    lab.onclick=()=>{ params.latitude=defaults.latitude; txt.value=params.latitude; val.textContent=params.latitude; draw(); updateMidpointLabels(); };
    row.append(lab,txt,val); wrap.appendChild(row); controls.latitude=txt; })();

  (()=>{ const row=document.createElement('div'); row.className='controls-row';
    const lab=document.createElement('label'); lab.textContent='longitude (°; E+, W-)'; lab.className='label-reset'; lab.title='Click to reset';
    const txt=document.createElement('input'); txt.type='text'; txt.value=params.longitude;
    const val=document.createElement('div'); val.className='value'; val.textContent=params.longitude;
    const commit=()=>{ const v=parseFloat(txt.value); if(!Number.isNaN(v)){ params.longitude=v; val.textContent=v; draw(); updateMidpointLabels(); } else { txt.value=params.longitude; } };
    txt.onblur=commit; txt.onkeydown=e=>{ if(e.key==='Enter') txt.blur(); };
    lab.onclick=()=>{ params.longitude=defaults.longitude; txt.value=params.longitude; val.textContent=params.longitude; draw(); updateMidpointLabels(); };
    row.append(lab,txt,val); wrap.appendChild(row); controls.longitude=txt; })();

  (()=>{ const row=document.createElement('div'); row.className='controls-row';
    const lab=document.createElement('label'); lab.textContent='US Time Zone'; lab.className='label-reset'; lab.title='Click to reset';
    const sel=document.createElement('select');
    TZ_OPTIONS.forEach(opt=>{ const o=document.createElement('option'); o.value=opt.id; o.textContent=opt.label; if(opt.id===params.timezone) o.selected=true; sel.appendChild(o); });
    const val=document.createElement('div'); val.className='value'; val.textContent=params.timezone;
    sel.onchange=e=>{ params.timezone=e.target.value; val.textContent=params.timezone; draw(); updateMidpointLabels(); };
    lab.onclick=()=>{ params.timezone=defaults.timezone; sel.value=params.timezone; val.textContent=params.timezone; draw(); updateMidpointLabels(); };
    row.append(lab,sel,val); wrap.appendChild(row); controls.timezone=sel; })();

  (()=>{ const row=document.createElement('div'); row.className='controls-row';
    const lab=document.createElement('label'); lab.textContent='12-Hour Format (AM/PM)'; lab.className='label-reset'; lab.title='Click to reset';
    const inner=document.createElement('div'); inner.style.display='flex'; inner.style.alignItems='center'; inner.style.gap='8px';
    const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=params.use12Hour;
    const txt=document.createElement('span'); txt.textContent=params.use12Hour?'Enabled':'Disabled';
    chk.onchange=e=>{ params.use12Hour=e.target.checked; txt.textContent=params.use12Hour?'Enabled':'Disabled'; draw(); updateMidpointLabels(); };
    lab.onclick=()=>{ params.use12Hour=defaults.use12Hour; chk.checked=params.use12Hour; txt.textContent=params.use12Hour?'Enabled':'Disabled'; draw(); updateMidpointLabels(); };
    inner.append(chk,txt);
    const val=document.createElement('div'); val.className='value'; val.textContent='';
    row.append(lab,inner,val); wrap.appendChild(row);
    controls.use12Hour = chk;
  })();
}

/* ===== Mirror brightness helpers ===== */
function setCctDisabled(half, disabled){
  const containerId = (half==='up') ? 'morning-cct' : 'evening-cct';
  const cont = document.getElementById(containerId);
  if (cont) cont.classList.toggle('is-locked', !!disabled);
  const keys = (half==='up') ? CCT_UP : CCT_DN;
  keys.forEach(k=>{
    if (controls[k]) controls[k].disabled = !!disabled;
  });
}
function syncCctWithBri(half){
  const src = (half==='up') ? BRIGHT_UP : BRIGHT_DN;
  const dst = (half==='up') ? CCT_UP    : CCT_DN;
  for (let i=0;i<src.length;i++){
    const sKey = src[i], dKey = dst[i];
    const val = params[sKey];
    params[dKey] = val;
    if (controls[dKey]){
      withSuppressedDraw(()=>{
        controls[dKey].value = String(val);
        controls[dKey].dispatchEvent(new Event('input'));
      });
    }
  }
}
function setCctMatchState(half, on){
  if (half==='up') params.match_cct_up = on; else params.match_cct_dn = on;
  if (on) syncCctWithBri(half);
  setCctDisabled(half, on);
}
function renderMirrorToggles(){
  const make = (slotId, half) => {
    const slot = document.getElementById(slotId);
    if (!slot) return;
    slot.innerHTML = '';
    const chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.checked = (half==='up') ? params.match_cct_up : params.match_cct_dn;
    const lbl = document.createElement('label');
    lbl.textContent = 'mirror brightness';
    lbl.onclick = () => { chk.checked = !chk.checked; chk.dispatchEvent(new Event('change')); };
    chk.onchange = (e) => setCctMatchState(half, e.target.checked);
    slot.appendChild(chk);
    slot.appendChild(lbl);
    controls[half==='up'?'match_cct_up':'match_cct_dn'] = chk;

    setCctDisabled(half, chk.checked);
    if (chk.checked) syncCctWithBri(half);
  };
  make('mirror-slot-up','up');
  make('mirror-slot-dn','dn');
}

function addMorningEveningUI(){
  function midLabel(isMorning, midHours){
    const {solarNoon, solarMidnight}=calculateSunTimes(params.month,params.latitude,params.longitude,params.timezone);
    let hour;
    if(isMorning){
      hour=(solarMidnight + (midHours/12)*((solarNoon - solarMidnight + 24)%24)) % 24;
    }else{
      hour=(solarNoon + (midHours/12)*((solarMidnight - solarNoon + 24)%24)) % 24;
    }
    return formatTime(hour, params.use12Hour);
  }
  const makeFormat=(key,isMorning,isMid=false)=> (v=>{
    if(isMid) return midLabel(isMorning, v);
    if(/decay/.test(key)) return v.toFixed(3);
    if(/steep/.test(key)) return v.toFixed(2);
    if(/gain/.test(key))  return v.toFixed(2);
    if(/offset_cct/.test(key)) return `${Math.round(v)} K`;
    if(/offset_bri/.test(key)) return `${Math.round(v)} pp`;
    return v.toFixed(2);
  });

  const mBri=document.getElementById('morning-bri');
  const mCct=document.getElementById('morning-cct');
  const eBri=document.getElementById('evening-bri');
  const eCct=document.getElementById('evening-cct');

  mBri.innerHTML=''; mCct.innerHTML=''; eBri.innerHTML=''; eCct.innerHTML='';

  const bounds={ mid:[0,12,0.01], steep:[0.05,8,0.05], decay:[0,0.20,0.005], gain:[0.10,3,0.01], offB:[-60,60,1], offC:[-2000,2000,50] };

  /* Morning Brightness */
  addSliderRow(mBri,{label:'Midpoint', key:'mid_bri_up', min:bounds.mid[0],max:bounds.mid[1],step:bounds.mid[2], format:makeFormat('mid_bri_up',true,true), defaultValue:defaults.mid_bri_up});
  addSliderRow(mBri,{label:'Steepness', key:'steep_bri_up', min:bounds.steep[0],max:bounds.steep[1],step:bounds.steep[2], format:makeFormat('steep_bri_up',true), defaultValue:defaults.steep_bri_up});
  addSliderRow(mBri,{label:'Decay', key:'decay_bri_up', min:bounds.decay[0],max:bounds.decay[1],step:bounds.decay[2], format:makeFormat('decay_bri_up',true), defaultValue:defaults.decay_bri_up});
  addSliderRow(mBri,{label:'Gain', key:'gain_bri_up', min:bounds.gain[0],max:bounds.gain[1],step:bounds.gain[2], format:makeFormat('gain_bri_up',true), defaultValue:defaults.gain_bri_up});
  addSliderRow(mBri,{label:'Offset', key:'offset_bri_up', min:bounds.offB[0],max:bounds.offB[1],step:bounds.offB[2], format:makeFormat('offset_bri_up',true), defaultValue:defaults.offset_bri_up});

  /* Morning CCT sliders */
  addSliderRow(mCct,{label:'Midpoint', key:'mid_cct_up', min:bounds.mid[0],max:bounds.mid[1],step:bounds.mid[2], format:makeFormat('mid_cct_up',true,true), defaultValue:defaults.mid_cct_up});
  addSliderRow(mCct,{label:'Steepness', key:'steep_cct_up', min:bounds.steep[0],max:bounds.steep[1],step:bounds.steep[2], format:makeFormat('steep_cct_up',true), defaultValue:defaults.steep_cct_up});
  addSliderRow(mCct,{label:'Decay', key:'decay_cct_up', min:bounds.decay[0],max:bounds.decay[1],step:bounds.decay[2], format:makeFormat('decay_cct_up',true), defaultValue:defaults.decay_cct_up});
  addSliderRow(mCct,{label:'Gain', key:'gain_cct_up', min:bounds.gain[0],max:bounds.gain[1],step:bounds.gain[2], format:makeFormat('gain_cct_up',true), defaultValue:defaults.gain_cct_up});
  addSliderRow(mCct,{label:'Offset', key:'offset_cct_up', min:bounds.offC[0],max:bounds.offC[1],step:bounds.offC[2], format:makeFormat('offset_cct_up',true), defaultValue:defaults.offset_cct_up});
  setCctMatchState('up', params.match_cct_up);

  /* Evening Brightness */
  addSliderRow(eBri,{label:'Midpoint', key:'mid_bri_dn', min:bounds.mid[0],max:bounds.mid[1],step:bounds.mid[2], format:makeFormat('mid_bri_dn',false,true), defaultValue:defaults.mid_bri_dn});
  addSliderRow(eBri,{label:'Steepness', key:'steep_bri_dn', min:bounds.steep[0],max:bounds.steep[1],step:bounds.steep[2], format:makeFormat('steep_bri_dn',false), defaultValue:defaults.steep_bri_dn});
  addSliderRow(eBri,{label:'Decay', key:'decay_bri_dn', min:bounds.decay[0],max:bounds.decay[1],step:bounds.decay[2], format:makeFormat('decay_bri_dn',false), defaultValue:defaults.decay_bri_dn});
  addSliderRow(eBri,{label:'Gain', key:'gain_bri_dn', min:bounds.gain[0],max:bounds.gain[1],step:bounds.gain[2], format:makeFormat('gain_bri_dn',false), defaultValue:defaults.gain_bri_dn});
  addSliderRow(eBri,{label:'Offset', key:'offset_bri_dn', min:bounds.offB[0],max:bounds.offB[1],step:bounds.offB[2], format:makeFormat('offset_bri_dn',false), defaultValue:defaults.offset_bri_dn});

  /* Evening CCT sliders */
  addSliderRow(eCct,{label:'Midpoint', key:'mid_cct_dn', min:bounds.mid[0],max:bounds.mid[1],step:bounds.mid[2], format:makeFormat('mid_cct_dn',false,true), defaultValue:defaults.mid_cct_dn});
  addSliderRow(eCct,{label:'Steepness', key:'steep_cct_dn', min:bounds.steep[0],max:bounds.steep[1],step:bounds.steep[2], format:makeFormat('steep_cct_dn',false), defaultValue:defaults.steep_cct_dn});
  addSliderRow(eCct,{label:'Decay', key:'decay_cct_dn', min:bounds.decay[0],max:bounds.decay[1],step:bounds.decay[2], format:makeFormat('decay_cct_dn',false), defaultValue:defaults.decay_cct_dn});
  addSliderRow(eCct,{label:'Gain', key:'gain_cct_dn', min:bounds.gain[0],max:bounds.gain[1],step:bounds.gain[2], format:makeFormat('gain_cct_dn',false), defaultValue:defaults.gain_cct_dn});
  addSliderRow(eCct,{label:'Offset', key:'offset_cct_dn', min:bounds.offC[0],max:bounds.offC[1],step:bounds.offC[2], format:makeFormat('offset_cct_dn',false), defaultValue:defaults.offset_cct_dn});
  setCctMatchState('dn', params.match_cct_dn);

  renderMirrorToggles();
}

/* =========================
   Draw & Reset
========================= */
function draw(){
  const {hours,ccts,bris,sunPower,morn,eve}=compute();
  renderPlot(hours,ccts,bris,sunPower, morn, eve);
  updatePreviewDeltas();
}

function resetMorningOnly(){
  ['mid_bri_up','steep_bri_up','decay_bri_up','gain_bri_up','offset_bri_up',
   'mid_cct_up','steep_cct_up','decay_cct_up','gain_cct_up','offset_cct_up'
  ].forEach(k=>params[k]=defaults[k]);
  params.match_cct_up = defaults.match_cct_up;
  addMorningEveningUI();
  draw();
}
function resetEveningOnly(){
  ['mid_bri_dn','steep_bri_dn','decay_bri_dn','gain_bri_dn','offset_bri_dn',
   'mid_cct_dn','steep_cct_dn','decay_cct_dn','gain_cct_dn','offset_cct_dn'
  ].forEach(k=>params[k]=defaults[k]);
  params.match_cct_dn = defaults.match_cct_dn;
  addMorningEveningUI();
  draw();
}

function bindSectionResets(){
  const rm=document.getElementById('reset-morning');
  const re=document.getElementById('reset-evening');
  if(rm) rm.onclick=resetMorningOnly;
  if(re) re.onclick=resetEveningOnly;
}

function resetAll(){
  Object.keys(defaults).forEach(k=>params[k]=defaults[k]);
  const now=new Date(); selectedHour = now.getHours() + now.getMinutes()/60;
  Object.keys(controls).forEach(k=>delete controls[k]);
  addMorningEveningUI();
  addRangesUI();
  addSunUI();
  bindSectionResets();
  const steps=document.getElementById('step-count'); if(steps){ steps.value='15'; }
  draw();
}

/* =========================
   Bootstrap
========================= */
addMorningEveningUI();
addRangesUI();
addSunUI();
bindSectionResets();
document.getElementById('reset-all').onclick=resetAll;

// Steps change should update preview
document.getElementById('step-count').addEventListener('input', updatePreviewDeltas);

// Initial draw
draw();
</script>
</body>
</html>
