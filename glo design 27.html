<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>HomeGlo designer — minimal merge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
  :root{
    --bg:#121212; --panel:#1e1e1e; --muted:#9aa0a6; --fg:#ffffff; --grid:#444;
    --accent:#1e90ff; --btn:#2a2a2a; --btnBorder:#444; --nowBlue:#66b8ff;
  }
  html,body{height:100%}
  body{font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:1.5rem; background:var(--bg); color:var(--fg)}
  .container{max-width:1200px;margin:0 auto;background:var(--panel);padding:1.25rem 1.5rem;border-radius:12px;box-shadow:0 2px 12px rgba(0,0,0,.35)}
  h2{margin:0 0 .75rem;color:#e0e0e0}
  #plot{height:460px;touch-action:none}
  .dragging #plot{cursor:ew-resize!important}

  .section{border:1px solid #2a2a2a;border-radius:10px;padding:12px;background:#1a1a1a;margin-top:10px}
  .section-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .section-title{font-size:1rem;font-weight:900;text-transform:uppercase;letter-spacing:.03em;color:var(--muted)}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .group-title{font-size:1rem;font-weight:800;color:var(--muted);margin:6px 0 6px;display:flex;align-items:center;gap:10px}

  .controls-row{display:grid;grid-template-columns:160px 1fr 110px;gap:8px;align-items:center;margin:8px 0}
  label{font-size:.9rem;color:var(--muted);font-weight:800;cursor:pointer}
  .value{font-variant-numeric:tabular-nums;text-align:right;color:#c9cfd6;font-weight:700}
  input[type=range]{width:100%;accent-color:var(--accent)}
  input[type=text],select{width:100%;padding:6px 8px;border:1px solid var(--btnBorder);border-radius:6px;background:var(--btn);color:#fff}
  input[type=number]{width:90px;padding:6px 8px;border:1px solid var(--btnBorder);border-radius:6px;background:var(--btn);color:#fff}

  .dual-range{position:relative;display:flex;align-items:center;gap:8px;width:100%}
  .dual-track{position:relative;flex:1;height:6px;background:var(--grid);border-radius:3px}
  .dual-range input[type=range]{position:absolute;width:100%;margin:0;background:transparent;appearance:none;height:6px;top:0}
  .dual-range input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;background:var(--accent);border-radius:50%;cursor:pointer;position:relative;z-index:2}
  .dual-range input[type=range]::-moz-range-thumb{width:16px;height:16px;background:var(--accent);border-radius:50%;cursor:pointer;position:relative;z-index:2}
  .dual-range input[id$="-min"]{z-index:2}
  .dual-range input[id$="-max"]{z-index:1}
  .fill{position:absolute;top:0;height:6px;background:var(--accent);border-radius:3px;z-index:0}
  .chip{font-size:.9rem;color:#c9cfd6;width:68px;text-align:right;font-variant-numeric:tabular-nums}

  .btn{border:1px solid var(--btnBorder);background:var(--btn);color:#c8c8c8;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:800;font-size:.9rem}
  .btn:hover{filter:brightness(1.1)}
  .control-bar{display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap}
  .ctrl-side{display:flex;align-items:center;gap:10px}
  .delta{color:#c9cfd6;font-variant-numeric:tabular-nums;opacity:.9}

  /* muted/disabled look for mirrored CCT sliders */
  .is-mirrored .controls-row input[type=range]{opacity:0.35}
  .mirror-chip{display:inline-flex;align-items:center;gap:6px;font-size:.85rem;color:#c9cfd6}
  .mirror-chip input{transform:translateY(1px)}
</style>
</head>
<body>
<div class="container">
  <h2>Glo designer</h2>
  <div id="plot"></div>

  <!-- Control bar -->
  <div class="section">
    <div class="section-head"><div class="section-title">Control</div></div>
    <div class="control-bar">
      <div class="ctrl-side">
        <button id="left-btn" class="btn">Step down</button>
        <span id="left-delta" class="delta">—</span>
      </div>
      <div class="ctrl-side">
        <label for="step-count">Steps</label>
        <input id="step-count" type="number" min="1" max="500" step="1" value="15" />
      </div>
      <div class="ctrl-side">
        <span id="right-delta" class="delta">—</span>
        <button id="right-btn" class="btn">Step up</button>
      </div>
    </div>
  </div>

  <div class="grid-2">
    <!-- Morning -->
    <div class="section">
      <div class="section-head">
        <div class="section-title">Morning</div>
        <button id="reset-morning" class="btn">Reset</button>
      </div>
      <div class="group-title">Midpoint</div>
      <div id="morning-mid"></div>
      <div class="group-title">Brightness</div>
      <div id="morning-bri"></div>
      <div class="group-title">
        <span>Color Temperature</span>
        <label class="mirror-chip"><input type="checkbox" id="mirror-up" checked> mirror brightness</label>
      </div>
      <div id="morning-cct"></div>
    </div>

    <!-- Evening -->
    <div class="section">
      <div class="section-head">
        <div class="section-title">Evening</div>
        <button id="reset-evening" class="btn">Reset</button>
      </div>
      <div class="group-title">Midpoint</div>
      <div id="evening-mid"></div>
      <div class="group-title">Brightness</div>
      <div id="evening-bri"></div>
      <div class="group-title">
        <span>Color Temperature</span>
        <label class="mirror-chip"><input type="checkbox" id="mirror-dn" checked> mirror brightness</label>
      </div>
      <div id="evening-cct"></div>
    </div>
  </div>

  <div class="section">
    <div class="section-head"><div class="section-title">Ranges</div></div>
    <div class="controls-row">
      <label>Brightness (min–max)</label>
      <div class="dual-range">
        <span id="min-intensity-value" class="chip">1</span>
        <div class="dual-track">
          <input type="range" id="min-intensity" min="0" max="100" step="1" value="1">
          <input type="range" id="max-intensity" min="0" max="100" step="1" value="100">
          <div class="fill" id="intensity-fill"></div>
        </div>
        <span id="max-intensity-value" class="chip">100</span>
      </div>
    </div>
    <div class="controls-row">
      <label>Color Temperature (K, min–max)</label>
      <div class="dual-range">
        <span id="min-temp-value" class="chip">500</span>
        <div class="dual-track">
          <input type="range" id="min-temp" min="500" max="6500" step="50" value="500">
          <input type="range" id="max-temp" min="500" max="6500" step="50" value="6500">
          <div class="fill" id="temp-fill"></div>
        </div>
        <span id="max-temp-value" class="chip">6500</span>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-head"><div class="section-title">Sun Position</div></div>
    <div class="controls-row">
      <label>Month</label>
      <select id="month"></select>
      <div class="value" id="month-label"></div>
    </div>
    <div class="controls-row">
      <label>Latitude (°; N+, S-)</label>
      <input id="lat" type="text" value="35.0">
      <div class="value" id="lat-label">35</div>
    </div>
    <div class="controls-row">
      <label>Longitude (°; E+, W-)</label>
      <input id="lon" type="text" value="-78.6">
      <div class="value" id="lon-label">-78.6</div>
    </div>
    <div class="controls-row">
      <label>US Time Zone</label>
      <select id="tz"></select>
      <div class="value" id="tz-label">US/Eastern</div>
    </div>
    <div class="controls-row">
      <label>12-Hour Format (AM/PM)</label>
      <div>
        <input id="fmt12" type="checkbox" checked>
        <span id="fmt12-label">Enabled</span>
      </div>
      <div class="value"></div>
    </div>
  </div>

  <div class="section" style="display:flex;justify-content:flex-end;gap:8px">
    <button id="reset-all" class="btn">Reset All</button>
  </div>
</div>

<script>
/* =========================
   Globals & defaults
========================= */
let plotDivRef=null;
let listenersBound=false;
let rafId=0,lastClientX=null;
let setCursorRef = ()=>{};
let selectedHour = new Date().getHours() + new Date().getMinutes()/60;

const SAMPLE_STEP = 0.1;
const SOLAR_LABEL_SIZE = 10;
const EPS_H = 1/3600;
const HYST_H = 1/720;
let activeHalf = null;

const UI = { sliders: {} };

function detectHalfSticky(h, prev){
  const { solarNoon, solarMidnight } = calculateSunTimes(
    params.month, params.latitude, params.longitude, params.timezone
  );
  if (h >= solarNoon + HYST_H || h < solarMidnight - HYST_H) return 'evening';
  if (h > solarMidnight + HYST_H && h <= solarNoon - HYST_H) return 'morning';
  return prev || ((h >= solarNoon) ? 'evening' : 'morning');
}

// Perceptual transforms
const GAMMA_B = 0.42;
function toPerceptualBriPercent(b){ const n=Math.max(0,Math.min(100,b))/100; return Math.pow(n, GAMMA_B); }
function toMired(k){ return 1e6/Math.max(500,Math.min(6500,k)); }
let W_B = 1.0, W_C = 0.6;

// App params
const defaults = {
  min_color_temp: 500, max_color_temp: 6500,
  min_brightness: 1,   max_brightness: 100,
  // Morning (up)
  mid_bri_up: 6.0, steep_bri_up: 1.0, gain_bri_up: 1.0, offset_bri_up: 0,
  mid_cct_up: 6.0, steep_cct_up: 1.0, gain_cct_up: 1.0, offset_cct_up: 0,
  // Evening (down)
  mid_bri_dn: 6.0, steep_bri_dn: 1.0, gain_bri_dn: 1.0, offset_bri_dn: 0,
  mid_cct_dn: 6.0, steep_cct_dn: 1.0, gain_cct_dn: 1.0, offset_cct_dn: 0,
  // mirror flags (default ON)
  mirror_up: true,
  mirror_dn: true,
  month: new Date().getMonth()+1,
  latitude: 35.0, longitude: -78.6, timezone: 'US/Eastern',
  use12Hour: true
};
const params = JSON.parse(JSON.stringify(defaults));

// UI maps
const MONTHS = ['January','February','March','April','May','June','July','August','September','October','November','December'];
const TZ_OPTIONS = ['US/Eastern','US/Central','US/Mountain','US/Pacific','US/Alaska','US/Arizona','US/Hawaii'];

// Arc caches
let arc = { hours:[], bris:[], ccts:[], sun:[] };
let morningArc=null, eveningArc=null;

/* =========================
   Solar helpers + Sun power (from fork)
========================= */
const CUM_DAYS=[0,31,59,90,120,151,181,212,243,273,304,334];
const deg2rad=d=>d*Math.PI/180, rad2deg=r=>r*180/Math.PI, doyForMonthMid=m=>CUM_DAYS[m-1]+15;

function utcOffsetFor(zone, month){
  const dst=(zone!=='US/Arizona'&&zone!=='US/Hawaii')&&(month>=3&&month<=10);
  switch(zone){
    case 'US/Eastern': return dst?-4:-5;
    case 'US/Central': return dst?-5:-6;
    case 'US/Mountain': return dst?-6:-7;
    case 'US/Pacific': return dst?-7:-8;
    case 'US/Alaska': return dst?-8:-9;
    case 'US/Arizona': return -7;
    case 'US/Hawaii': return -10;
    default: return -5;
  }
}
function solarDeclinationRad(doy){
  const g=2*Math.PI/365*(doy-1);
  return 0.006918-0.399912*Math.cos(g)+0.070257*Math.sin(g)-0.006758*Math.cos(2*g)+0.000907*Math.sin(2*g)-0.002697*Math.cos(3*g)+0.00148*Math.sin(3*g);
}
function equationOfTimeMinutes(doy){
  const B=2*Math.PI*(doy-81)/364;
  return 9.87*Math.sin(2*B)-7.53*Math.cos(B)-1.5*Math.sin(B);
}
function calculateSunTimes(month, lat, lon, tz){
  const doy=doyForMonthMid(month), phi=deg2rad(lat), delta=solarDeclinationRad(doy);
  const utc=utcOffsetFor(tz,month);
  const LSTM=15*utc; const TC=equationOfTimeMinutes(doy)+4*(lon-LSTM);
  const solarNoon=12 - TC/60;
  const solarMidnight=(solarNoon+12)%24;
  const cosH=-Math.tan(phi)*Math.tan(delta);
  if (cosH>1) return {sunrise:null,sunset:null,solarNoon,solarMidnight};
  if (cosH<-1) return {sunrise:0,sunset:24,solarNoon,solarMidnight};
  const H=rad2deg(Math.acos(cosH));
  return {sunrise:(12-H/15)-TC/60, sunset:(12+H/15)-TC/60, solarNoon, solarMidnight};
}
function hourAngleRad(clockHour,utcOffset,longitude,doy){ const LST = (clockHour + (equationOfTimeMinutes(doy)+4*(longitude-15*utcOffset))/60); return deg2rad(15*(LST-12)); }
function sunElevationDeg(clockHour,month,latDeg,lonDeg,tz){ const doy=doyForMonthMid(month); const utc=utcOffsetFor(tz,month); const phi=deg2rad(latDeg), delta=solarDeclinationRad(doy), H=hourAngleRad(clockHour,utc,lonDeg,doy); return rad2deg(Math.asin(Math.sin(phi)*Math.sin(delta)+Math.cos(phi)*Math.cos(delta)*Math.cos(H))); }
function clearSkyGHI(hour,month,lat,lon,tz){ const alt=sunElevationDeg(hour,month,lat,lon,tz); if(alt<=0) return null; const cosZ=Math.sin(deg2rad(alt)); return 1098*cosZ*Math.exp(-0.059/cosZ)*300/1098; }

function formatTime(hour,use12){
  let total=Math.round(hour*60); let h=Math.floor(total/60), m=total%60;
  if(!use12) return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
  const ampm=h<12?'AM':'PM'; h=h%12; if(h===0) h=12; return `${h}:${String(m).padStart(2,'0')}${ampm}`;
}

/* =========================
   Curves (half-day)
========================= */
function mapMorning(t,{m,k,gain,offset,outMin,outMax}){
  const base = 1/(1+Math.exp(-k*(t-m)));
  const scaled = Math.max(0, Math.min(1, base * gain));
  const span = (outMax - outMin);
  let y = outMin + span * scaled;
  // offset is percentage of span (−50..+50)
  y += span * (offset / 100);
  return Math.max(outMin, Math.min(outMax, y));
}
function mapEvening(t,{m,k,gain,offset,outMin,outMax}){
  const te = t - 12;
  const base = (1 - (1/(1+Math.exp(-k*(te-m)))));
  const scaled = Math.max(0, Math.min(1, base * gain));
  const span = (outMax - outMin);
  let y = outMin + span * scaled;
  y += span * (offset / 100);
  return Math.max(outMin, Math.min(outMax, y));
}

/* =========================
   Compute series (add sunPower)
========================= */
function compute(){
  const {solarNoon, solarMidnight, sunrise, sunset} = calculateSunTimes(
    params.month, params.latitude, params.longitude, params.timezone
  );

  const briBounds=[params.min_brightness, params.max_brightness];
  const cctBounds=[params.min_color_temp, params.max_color_temp];

  const mHours=[], mBri=[], mCct=[], mSun=[];
  for(let t=0; t<12; t+=SAMPLE_STEP){
    const hour=(solarMidnight + (t/12)*((solarNoon - solarMidnight + 24)%24))%24;
    mHours.push(hour);
    let vb=mapMorning(t,{m:params.mid_bri_up,k:params.steep_bri_up,gain:params.gain_bri_up,offset:params.offset_bri_up,outMin:briBounds[0],outMax:briBounds[1]});
    let vc=mapMorning(t,{m:params.mid_cct_up,k:params.steep_cct_up,gain:params.gain_cct_up,offset:params.offset_cct_up,outMin:cctBounds[0],outMax:cctBounds[1]});
    mBri.push(Math.max(0,Math.min(100,vb)));
    mCct.push(Math.max(500,Math.min(6500,vc)));
    mSun.push(clearSkyGHI(hour,params.month,params.latitude,params.longitude,params.timezone));
  }
  mHours.push(solarNoon%24);
  mBri.push(params.max_brightness);
  mCct.push(params.max_color_temp);
  mSun.push(clearSkyGHI(solarNoon%24,params.month,params.latitude,params.longitude,params.timezone));

  const eHours=[], eBri=[], eCct=[], eSun=[];
  eHours.push(solarNoon%24);
  eBri.push(params.max_brightness);
  eCct.push(params.max_color_temp);
  eSun.push(clearSkyGHI(solarNoon%24,params.month,params.latitude,params.longitude,params.timezone));
  for(let t=12+SAMPLE_STEP; t<=24.0001; t+=SAMPLE_STEP){
    const hour=(solarNoon + ((t-12)/12)*((solarMidnight - solarNoon + 24)%24))%24;
    eHours.push(hour);
    let vb=mapEvening(t,{m:params.mid_bri_dn,k:params.steep_bri_dn,gain:params.gain_bri_dn,offset:params.offset_bri_dn,outMin:briBounds[0],outMax:briBounds[1]});
    let vc=mapEvening(t,{m:params.mid_cct_dn,k:params.steep_cct_dn,gain:params.gain_cct_dn,offset:params.offset_cct_dn,outMin:cctBounds[0],outMax:cctBounds[1]});
    eBri.push(Math.max(0,Math.min(100,vb)));
    eCct.push(Math.max(500,Math.min(6500,vc)));
    eSun.push(clearSkyGHI(hour,params.month,params.latitude,params.longitude,params.timezone));
  }
  eBri[eBri.length-1] = params.min_brightness;
  eCct[eCct.length-1] = params.min_color_temp;

  const hours=[...mHours,...eHours], bri=[...mBri,...eBri], cct=[...mCct,...eCct], sun=[...mSun,...eSun];
  const idx=hours.map((_,i)=>i).sort((a,b)=>hours[a]-hours[b]);
  const H=idx.map(i=>hours[i]), B=idx.map(i=>bri[i]), C=idx.map(i=>cct[i]), S=idx.map(i=>sun[i]);

  return {
    hours:H, bris:B, ccts:C, sunPower:S,
    morn:{hours:mHours, bris:mBri, ccts:mCct},
    eve: {hours:eHours, bris:eBri, ccts:eCct},
    solar:{sunrise, sunset, solarNoon, solarMidnight}
  };
}

/* =========================
   Perceptual half arcs
========================= */
function buildHalfArc(half){
  const H=half.hours, B=half.bris, K=half.ccts;
  const PB=B.map(toPerceptualBriPercent);
  const mMin=toMired(params.max_color_temp), mMax=toMired(params.min_color_temp);
  const PC=K.map(k=> (toMired(k)-mMin)/Math.max(1e-9,(mMax-mMin)));

  const S=[0];
  for(let i=1;i<H.length;i++){
    let span=H[i]-H[i-1];
    if(span<-12) span+=24;
    if(span>12)  span-=24;
    const dB=PB[i]-PB[i-1], dC=PC[i]-PC[i-1];
    S.push(S[i-1] + Math.hypot(W_B*dB, W_C*dC));
  }
  const total=S[S.length-1];

  function sAtHour(h){
    for(let i=1;i<H.length;i++){
      let h0=H[i-1], h1=H[i];
      let span=h1-h0;
      if(span<-12) span+=24;
      if(span>12)  span-=24;
      let dh=h-h0;
      if(dh<-12) dh+=24;
      if(dh>12)  dh-=24;
      const between = span>=0 ? (dh>=0 && dh<=span) : (dh<=0 && dh>=span);
      if(between){
        const t=(span===0)?0:(dh/span);
        return S[i-1] + t*(S[i]-S[i-1]);
      }
    }
    const dStart=Math.min(Math.abs(h-H[0]),24-Math.abs(h-H[0]));
    const dEnd=Math.min(Math.abs(h-H[H.length-1]),24-Math.abs(h-H[H.length-1]));
    return (dStart<=dEnd)?0:total;
  }
  function hourAtS(s){
    if(s<=0) return H[0];
    if(s>=total) return H[H.length-1];
    for(let i=1;i<S.length;i++){
      if(s<=S[i]){
        const t=(s-S[i-1])/Math.max(1e-9,(S[i]-S[i-1]));
        let h0=H[i-1], h1=H[i];
        let span=h1-h0;
        if(span<-12) span+=24;
        if(span>12)  span-=24;
        let h=h0+t*span;
        if(h<0) h+=24;
        if(h>=24) h-=24;
        return h;
      }
    }
    return H[H.length-1];
  }
  function makeGrid(stepCount){
    const n=Math.max(1,Math.min(500,stepCount));
    const pitch=total/n;
    const ticks=[]; for(let i=0;i<=n;i++) ticks.push(i*pitch);
    return {pitch,ticks};
  }
  return {hours:H, bris:B, ccts:K, S, total, sAtHour, hourAtS, makeGrid};
}
function rebuildHalfArcCaches(morn, eve){
  morningArc=buildHalfArc(morn);
  eveningArc=buildHalfArc(eve);
}
function currentHalf(){
  const { solarNoon, solarMidnight } = calculateSunTimes(
    params.month, params.latitude, params.longitude, params.timezone
  );
  const h = selectedHour;
  if (Math.abs(h - solarNoon) <= EPS_H) return 'morning';
  if (Math.abs(h - solarMidnight) <= EPS_H) return 'evening';
  if (h > solarNoon + EPS_H || h < solarMidnight - EPS_H) return 'evening';
  return 'morning';
}

/* =========================
   Stepper (uniform perceptual ticks)
========================= */
function computeActionTarget(action){
  if (!morningArc || !eveningArc) return null;

  let half   = activeHalf || detectHalfSticky(selectedHour, activeHalf);
  let arcRef = (half === 'morning') ? morningArc : eveningArc;

  const stepCount = Math.max(1, Math.min(500, parseInt(document.getElementById('step-count')?.value || '15', 10)));
  const { pitch, ticks } = arcRef.makeGrid(stepCount);

  const minIdx = 0, maxIdx = ticks.length - 1;
  const sStart = 0, sEnd = arcRef.total;
  if (!(sEnd > 0)) return null;

  let sNow = arcRef.sAtHour(selectedHour);
  if (sNow < sStart) sNow = sStart;
  if (sNow > sEnd)   sNow = sEnd;

  const sDir = (half === 'morning')
    ? (action === 'brighten' ? +1 : -1)
    : (action === 'brighten' ? -1 : +1);

  const iBelow = Math.floor((sNow + 1e-12) / pitch);
  const iAbove = Math.ceil ((sNow - 1e-12) / pitch);

  let candidateIdx = (sDir > 0)
    ? Math.min(maxIdx, iBelow + 1)
    : Math.max(minIdx, iAbove - 1);

  const EPS_S = Math.max(1e-9, pitch * 1e-3);
  const atStart = Math.abs(sNow - ticks[minIdx]) <= EPS_S;
  const atEnd   = Math.abs(sNow - ticks[maxIdx]) <= EPS_S;

  if ((atEnd && sDir > 0) || (atStart && sDir < 0)) return null;

  const b0   = interpAtHour(arc.hours, arc.bris, selectedHour);
  const want = (action === 'brighten') ? +1 : -1;
  const EPSB = 0.1;
  function briAtIdx(i){
    const h = arcRef.hourAtS(ticks[i]);
    return interpAtHour(arc.hours, arc.bris, h);
  }
  let chosenIdx = candidateIdx;
  for (let tries=0; tries<3; tries++){
    const dB = briAtIdx(chosenIdx) - b0;
    if ((want > 0 && dB >= EPSB) || (want < 0 && dB <= -EPSB)) break;
    const n = chosenIdx + sDir;
    if (n < minIdx || n > maxIdx) break;
    chosenIdx = n;
  }
  return arcRef.hourAtS(ticks[chosenIdx]);
}

function stepArc(action){
  const hTarget=computeActionTarget(action);
  if(hTarget==null) return;
  setCursorRef(hTarget);
}

/* =========================
   Interp + formatting
========================= */
function interpAtHour(hours, arr, h){
  if(h<=hours[0]) return arr[0];
  for(let i=1;i<hours.length;i++){
    if(h<=hours[i]){
      const h0=hours[i-1], h1=hours[i], t=(h-h0)/(h1-h0);
      return arr[i-1] + t*(arr[i]-arr[i-1]);
    }
  }
  return arr[arr.length-1];
}
function cctToRGB(k){
  k=Math.max(500,Math.min(6500,k)); const t=k/100; let r,g,b;
  if(t<=66) r=255; else r=329.698727446*Math.pow(t-60,-0.1332047592);
  if(t<=66) g=99.4708025861*Math.log(t)-161.1195681661; else g=288.1221695283*Math.pow(t-60,-0.0755148492);
  if(t>=66) b=255; else if(t<=19) b=0; else b=138.5177312231*Math.log(t-10)-305.0447927307;
  const clamp=v=>Math.max(0,Math.min(255,Math.round(v))); return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
}
// Slight bluish tint for CCT > 6000K (from fork idea)
function parseRGB(str){ const m=str.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/i); return m?[+m[1],+m[2],+m[3]]:[255,255,255]; }
function blend(a,b,t){ return [Math.round(a[0]*(1-t)+b[0]*t), Math.round(a[1]*(1-t)+b[1]*t), Math.round(a[2]*(1-t)+b[2]*t)]; }
function lineColorForCCT(k){
  const base=parseRGB(cctToRGB(k));
  if(k<=6000) return `rgb(${base[0]},${base[1]},${base[2]})`;
  const f=Math.min(1,Math.max(0,(k-6000)/500));
  const blue=[150,200,255]; const t=0.6*f; // very light blue tint
  const [r,g,b]=blend(base,blue,t); return `rgb(${r},${g},${b})`;
}
function fmtSigned(n,unit){
  const sign=n>0?'+':(n<0?'−':'±'); const abs=Math.abs(Math.round(n));
  return `${sign}${abs}${unit}`;
}
function fmtTimeDelta(hNew,hOld){
  const minutes=Math.round((hNew-hOld)*60);
  const sign=minutes>0?'+':(minutes<0?'−':'±'); const a=Math.abs(minutes);
  const hh=Math.floor(a/60), mm=a%60; if(hh>0) return `${sign}${hh}h ${mm}m`;
  return `${sign}${mm}m`;
}

/* =========================
   Plot rendering (add sun power + legends + now label)
========================= */
function buildHomeGloColored(x,bri,cct){
  const segs=[];
  for(let i=1;i<x.length;i++){
    if(x[i]-x[i-1]>1.5) continue;
    const midC=0.5*(cct[i-1]+cct[i]);
    segs.push({type:'scatter',mode:'lines',x:[x[i-1],x[i]],y:[bri[i-1],bri[i]],
      line:{width:4,color:lineColorForCCT(midC)},name:'HomeGlo',yaxis:'y',hoverinfo:'skip',showlegend:false});
  }
  return segs;
}
function buildSunColored(x,sun){
  const segs=[];
  for(let i=1;i<x.length;i++){
    if(sun[i-1]==null || sun[i]==null) continue;
    if(x[i]-x[i-1] > 1.5) continue;
    const mid=0.5*(sun[i-1]+sun[i]);
    let r=255,g=255,b=255;
    if(mid<=2){ r=255; g=255; b=200; }
    else if(mid>200){ const t=(mid-200)/100; r=Math.round(255-55*t); g=Math.round(255-55*t); b=255; }
    else { const t=(mid-2)/198; r=255; g=255; b=Math.round(200+t*(255-200)); }
    segs.push({type:'scatter',mode:'lines',x:[x[i-1],x[i]],y:[sun[i-1],sun[i]],
               line:{width:1,color:`rgb(${r},${g},${b})`,dash:'dot'},name:'Sun power',yaxis:'y',hoverinfo:'skip',showlegend:false});
  }
  return segs;
}

function renderPlot(series){
  const {hours,ccts,bris,morn,eve,solar,sunPower}=series;
  rebuildHalfArcCaches(morn, eve);

  arc.hours=hours.slice();
  arc.bris=bris.map(v=>Math.round(v));
  arc.ccts=ccts.slice();
  arc.sun=sunPower.slice();

  const segs=buildHomeGloColored(hours,bris.map(v=>Math.round(v)),ccts);
  const sunSegs=buildSunColored(hours,sunPower);

  // Legend entries (dummy lines for labels only)
  const homeLegend={type:'scatter',mode:'lines',x:[null],y:[null],name:'HomeGlo',
    line:{width:4,color:'#fff'},hoverinfo:'skip',showlegend:true,yaxis:'y'};
  const sunLegend={type:'scatter',mode:'lines',x:[null],y:[null],name:'Sun power',
    line:{width:1,color:'#fff',dash:'dot'},hoverinfo:'skip',showlegend:true,yaxis:'y'};

  const hoverProxy={type:'scatter',mode:'lines',x:hours,y:bris,name:'HomeGlo (hover)',
    line:{width:14,color:'rgba(0,0,0,0)'},
    hovertemplate:'%{text}<br>Home Glo %{y:.0f}%<br>color temperature %{customdata:.0f} K<extra></extra>',
    text:hours.map(h=>formatTime(h,params.use12Hour)), customdata:ccts, yaxis:'y', showlegend:false};

  const now=new Date(); const nowHour=now.getHours()+now.getMinutes()/60;
  const nowBri=interpAtHour(hours,bris,nowHour);
  const nowCCT=interpAtHour(hours,ccts,nowHour);
  const nowOutline=getComputedStyle(document.documentElement).getPropertyValue('--nowBlue').trim()||'#66b8ff';
  const nowMarker={type:'scatter',mode:'markers',x:[nowHour],y:[nowBri],name:'now',
    marker:{size:10,color:cctToRGB(nowCCT),line:{width:2,color:nowOutline}},hoverinfo:'skip',showlegend:false};

  const annotations=[];
  const annotate=(xpos,label,color)=>{ if(xpos==null) return;
    annotations.push({x:xpos,y:-0.15,yref:'paper',text:`${label}<br>${formatTime(xpos,params.use12Hour)}`,
      showarrow:false,font:{size:SOLAR_LABEL_SIZE,color:color||'#fff'},xanchor:'center',yanchor:'top',cliponaxis:false});
  };
  annotate(solar.sunrise,'sunrise');
  annotate(solar.sunset,'sunset');
  annotate(solar.solarNoon,'solar noon');
  annotate(solar.solarMidnight,'solar midnight');

  // White "now" label with time
  annotations.push({
    x: nowHour, y: -0.10, yref: 'paper',
    text: `now ${formatTime(nowHour, params.use12Hour).toLowerCase()}`,
    showarrow: false,
    font: { size: SOLAR_LABEL_SIZE, color: '#ffffff', weight: 800 },
    xanchor: 'center', yanchor: 'top', cliponaxis: false
  });

  const selBri = interpAtHour(hours,bris,selectedHour);
  const selCCT = interpAtHour(hours,ccts,selectedHour);
  const selectionMarker={ type:'scatter',mode:'markers',x:[selectedHour],y:[selBri],name:'selected',
    marker:{size:12,color:cctToRGB(selCCT),line:{width:2,color:'#fff'}},hoverinfo:'skip',showlegend:false };
  const cursorShape={type:'line',xref:'x',x0:selectedHour,x1:selectedHour,yref:'paper',y0:0,y1:1,line:{color:'#1e90ff',width:2}};

  const data=[...segs, homeLegend, sunLegend, hoverProxy, ...sunSegs, nowMarker, selectionMarker];

  const layout={
    dragmode:'pan', hovermode:'closest',
    xaxis:{range:[0,24], tickmode:'array', tickvals:[0,3,6,9,12,15,18,21,24],
      ticktext: params.use12Hour? ['12am','3am','6am','9am','12pm','3pm','6pm','9pm','12am']
                                : ['00:00','03:00','06:00','09:00','12:00','15:00','18:00','21:00','00:00'],
      tickfont:{color:'#fff'}, showgrid:true, gridcolor:'#444', fixedrange:true,
      minor:{tickmode:'array', tickvals:Array.from({length:25},(_,i)=>i), ticks:'outside', ticklen:4, tickcolor:'#444', showgrid:true, minor_gridcolor:'#333'} },
    yaxis:{title:'brightness', range:[0,300], autorange:false, tickfont:{color:'#fff'}, fixedrange:true, showgrid:true, gridcolor:'#444'},
    showlegend:true, legend:{x:0.02,y:0.98, font:{color:'#fff'}, bgcolor:'rgba(0,0,0,.5)'},
    margin:{t:24,b:96},
    annotations:[
      ...annotations,
      {
        x:selectedHour, y:selBri,
        text:`${formatTime(selectedHour,params.use12Hour)}<br><b>${Math.round(selBri)}%</b> • ${Math.round(selCCT)} K`,
        showarrow:true, arrowhead:4, arrowsize:1, arrowwidth:1, arrowcolor:'rgba(200,200,200,0.8)',
        ax:0, ay:-40, bgcolor:'rgba(0,0,0,0.65)', bordercolor:'rgba(150,150,150,0.6)', borderwidth:1, font:{color:'#fff',size:12}
      }
    ],
    shapes:[cursorShape], paper_bgcolor:'#1e1e1e', plot_bgcolor:'#1e1e1e', uirevision:'keep'
  };
  const config={responsive:true, editable:false, scrollZoom:false, doubleClick:false, displayModeBar:false};

  function setCursor(xh){
    if(!plotDivRef) return;
    const clamped=Math.max(0,Math.min(24,xh)); selectedHour=clamped;
    const yB=interpAtHour(hours,bris,clamped);
    const yK=interpAtHour(hours,ccts,clamped);

    Plotly.relayout(plotDivRef, {'shapes[0].x0':clamped,'shapes[0].x1':clamped});
    const selIdx=plotDivRef.data.findIndex(t=>t && t.name==='selected');
    if(selIdx!==-1) Plotly.restyle(plotDivRef, {x:[[clamped]], y:[[yB]], 'marker.color':[[cctToRGB(yK)]]}, selIdx);

    const annLen=(plotDivRef.layout.annotations||[]).length; const annIndex=annLen-1;
    const upd={}; upd[`annotations[${annIndex}].x`]=clamped; upd[`annotations[${annIndex}].y`]=yB;
    upd[`annotations[${annIndex}].text`]=`${formatTime(clamped,params.use12Hour)}<br><b>${Math.round(yB)}%</b> • ${Math.round(yK)} K`;
    activeHalf = detectHalfSticky(selectedHour, activeHalf);

    Plotly.relayout(plotDivRef, upd);

    updatePreviewDeltas();
  }
  setCursorRef=setCursor;

  if(plotDivRef){ Plotly.react(plotDivRef,data,layout,config); }
  else{
    Plotly.newPlot('plot',data,layout,config).then(div=>{
      plotDivRef=div; bindInteractionsOnce();
    });
  }
}

/* =========================
   Interactions & preview
========================= */
function bindInteractionsOnce(){
  if(listenersBound||!plotDivRef) return;

  const getPlotArea=()=> plotDivRef.querySelector('.cartesianlayer .plot')||plotDivRef;
  const mapClientXToHour=(x)=>{ const r=getPlotArea().getBoundingClientRect(); const t=(x-r.left)/r.width; return Math.max(0,Math.min(24,24*t)); };

  let dragging=false;
  const tick=()=>{ if(lastClientX==null){rafId=0;return;} setCursorRef(mapClientXToHour(lastClientX)); rafId=0; };
  const onPointerDown=e=>{ dragging=true; document.body.classList.add('dragging'); lastClientX=e.clientX; if(!rafId) rafId=requestAnimationFrame(tick); };
  const onPointerMove=e=>{ if(!dragging) return; lastClientX=e.clientX; if(!rafId) rafId=requestAnimationFrame(tick); };
  const onPointerUp=()=>{ dragging=false; document.body.classList.remove('dragging'); lastClientX=null; };
  const onClick=e=> setCursorRef(mapClientXToHour(e.clientX));

  const area=plotDivRef;
  area.addEventListener('pointerdown', onPointerDown, {passive:true});
  window.addEventListener('pointermove', onPointerMove, {passive:true});
  window.addEventListener('pointerup', onPointerUp, {passive:true});
  area.addEventListener('click', onClick, {passive:true});

  plotDivRef.on('plotly_relayout', ev=>{
    if(('xaxis.range[0]' in ev)||('xaxis.range[1]' in ev)||('yaxis.range[0]' in ev)||('yaxis.range[1]' in ev)){
      Plotly.relayout(plotDivRef, {'xaxis.range':[0,24],'yaxis.range':[0,300]});
    }
  });

  document.getElementById('step-count').addEventListener('input', updatePreviewDeltas);

  listenersBound=true;
}
function updatePreviewDeltas(){
  if (!activeHalf) activeHalf = detectHalfSticky(selectedHour, activeHalf);

  const leftBtn   = document.getElementById('left-btn');
  const rightBtn  = document.getElementById('right-btn');
  const leftDelta = document.getElementById('left-delta');
  const rightDelta= document.getElementById('right-delta');

  if (activeHalf === 'morning'){
    leftBtn.textContent  = 'Step down';
    leftBtn.onclick      = () => stepArc('dim');
    rightBtn.textContent = 'Step up';
    rightBtn.onclick     = () => stepArc('brighten');
  } else {
    leftBtn.textContent  = 'Step up';
    leftBtn.onclick      = () => stepArc('brighten');
    rightBtn.textContent = 'Step down';
    rightBtn.onclick     = () => stepArc('dim');
  }

  const b0 = interpAtHour(arc.hours, arc.bris, selectedHour);
  const k0 = interpAtHour(arc.hours, arc.ccts, selectedHour);

  function preview(action){
    const hT = computeActionTarget(action);
    if (hT==null) return 'no change';
    const b1 = interpAtHour(arc.hours, arc.bris, hT);
    const k1 = interpAtHour(arc.hours, arc.ccts, hT);
    return `${fmtTimeDelta(hT, selectedHour)}, ${fmtSigned(b1-b0,'%')}, ${fmtSigned(k1-k0,'K')}`;
  }

  if (activeHalf === 'morning'){
    leftDelta.textContent  = preview('dim');
    rightDelta.textContent = preview('brighten');
  } else {
    leftDelta.textContent  = preview('brighten');
    rightDelta.textContent = preview('dim');
  }
}

/* =========================
   UI (sliders & controls) — minimal, preserves core behavior
========================= */
if (!activeHalf) activeHalf = detectHalfSticky(selectedHour, 'morning');

function resetSlider(key){
  const ui = UI.sliders[key];
  if(!ui) return;
  const def = ui.def;
  params[key] = def;
  ui.input.value = def;
  ui.val.textContent = ui.format ? ui.format(def) : def;
  maybeMirrorParam(key);
  draw();
}

function addSliderRow(parent,{ label, key, min, max, step, format, def, syncKeys = [], labelHidden = false }){
  const row = document.createElement('div');
  row.className = 'controls-row';

  const lab = document.createElement('label');
  lab.textContent = labelHidden ? '' : label;

  const trackWrap = document.createElement('div');
  trackWrap.style.position = 'relative';
  trackWrap.style.width = '100%';

  const input = document.createElement('input');
  input.type = 'range';
  input.min = min; input.max = max; input.step = step; input.value = params[key];

  const pin = document.createElement('div');
  pin.style.position = 'absolute'; pin.style.top = '50%'; pin.style.transform = 'translate(-50%, -50%)';
  pin.style.width = '2px'; pin.style.height = '12px'; pin.style.background = 'rgba(255,255,255,0.7)'; pin.style.borderRadius = '1px'; pin.style.pointerEvents = 'none';
  trackWrap.appendChild(input); trackWrap.appendChild(pin);

  const val = document.createElement('div'); val.className = 'value';
  const fmt = (v) => format ? format(v) : (typeof v === 'number' ? v.toFixed(2) : v);

  function positionPinAtDefault(){ const THUMB=16; const w=input.clientWidth||0; const t=(def-min)/(max-min); const px=t*Math.max(0,w-THUMB)+THUMB/2; pin.style.left=`${px}px`; }
  requestAnimationFrame(positionPinAtDefault); window.addEventListener('resize', positionPinAtDefault);

  const apply = (v)=>{
    params[key]=v; val.textContent = fmt(v);
    if (syncKeys && syncKeys.length){
      syncKeys.forEach((k)=>{ params[k]=v; const ui=UI.sliders[k]; if(ui){ ui.input.value=v; ui.val.textContent=ui.format?ui.format(v):v; }});
    }
    maybeMirrorParam(key);
    draw();
  };

  input.oninput = (e)=> apply(parseFloat(e.target.value));
  val.textContent = fmt(params[key]);
  if (!labelHidden) lab.addEventListener('click', ()=> resetSlider(key));

  row.append(lab, trackWrap, val);
  parent.appendChild(row);
  UI.sliders[key] = { input, val, labelEl: lab, format: fmt, def, rowEl: row, pinEl: pin, min, max, _repositionPin: positionPinAtDefault };
}

function maybeMirrorParam(key){
  if(key.includes('_bri_')){
    const half = key.endsWith('_up') || key.includes('_up') ? 'up' : 'dn';
    if ((half==='up'  && params.mirror_up) || (half==='dn'  && params.mirror_dn)){
      const cctKey = key.replace('_bri_','_cct_');
      params[cctKey] = params[key];
      const ui = UI.sliders[cctKey];
      if(ui){ ui.input.value = params[cctKey]; ui.val.textContent = ui.format ? ui.format(params[cctKey]) : params[cctKey]; }
    }
  }
}

function setCCTMirrorUI(half, enabled){
  const keys = (half==='up')
    ? ['mid_cct_up','steep_cct_up','gain_cct_up','offset_cct_up']
    : ['mid_cct_dn','steep_cct_dn','gain_cct_dn','offset_cct_dn'];
  keys.forEach(k=>{ const ui = UI.sliders[k]; if(!ui) return; ui.input.disabled = enabled; ui.rowEl.classList.toggle('is-mirrored', enabled); });
  if(enabled){
    const map = (half==='up')
      ? [['mid_bri_up','mid_cct_up'],['steep_bri_up','steep_cct_up'],['gain_bri_up','gain_cct_up'],['offset_bri_up','offset_cct_up']]
      : [['mid_bri_dn','mid_cct_dn'],['steep_bri_dn','steep_cct_dn'],['gain_bri_dn','gain_cct_dn'],['offset_bri_dn','offset_cct_dn']];
    map.forEach(([briKey,cctKey])=>{ params[cctKey] = params[briKey]; const ui = UI.sliders[cctKey]; if(ui){ ui.input.value = params[cctKey]; ui.val.textContent = ui.format ? ui.format(params[cctKey]) : params[cctKey]; } });
  }
}

function addMorningEveningUI() {
  const bounds = { mid:[0,12,0.01], steep:[0.05,8,0.05], gain:[0.10,3,0.01], offPct:[-50,50,1] };
  const fmtMid = (isMorning) => (v => {
    const { solarNoon, solarMidnight } = calculateSunTimes(params.month, params.latitude, params.longitude, params.timezone);
    const hour = isMorning
      ? (solarMidnight + (v / 12) * ((solarNoon - solarMidnight + 24) % 24)) % 24
      : (solarNoon + (v / 12) * ((solarMidnight - solarNoon + 24) % 24)) % 24;
    return formatTime(hour, params.use12Hour);
  });
  const fmtPct = v => `${v > 0 ? '+' : v < 0 ? '−' : '±'}${Math.abs(Math.round(v))}%`;

  const mMid = document.getElementById('morning-mid');
  const mB = document.getElementById('morning-bri');
  const mC = document.getElementById('morning-cct');
  const eMid = document.getElementById('evening-mid');
  const eB = document.getElementById('evening-bri');
  const eC = document.getElementById('evening-cct');
  mMid.innerHTML = mB.innerHTML = mC.innerHTML = eMid.innerHTML = eB.innerHTML = eC.innerHTML = '';

  function addMid(isMorning){
    const keyMid = isMorning ? 'mid_bri_up' : 'mid_bri_dn';
    const keyTwin = isMorning ? 'mid_cct_up' : 'mid_cct_dn';
    const defMid = isMorning ? defaults.mid_bri_up : defaults.mid_bri_dn;
    const parent = isMorning ? mMid : eMid;
    addSliderRow(parent, { label:'', key:keyMid, min:bounds.mid[0], max:bounds.mid[1], step:bounds.mid[2], format:fmtMid(isMorning), def:defMid, syncKeys:[keyTwin], labelHidden:true });
  }
  addMid(true); addMid(false);

  // Morning Brightness
  addSliderRow(mB, { label:'Steepness', key:'steep_bri_up', min:bounds.steep[0], max:bounds.steep[1], step:bounds.steep[2], def:defaults.steep_bri_up });
  addSliderRow(mB, { label:'Gain',      key:'gain_bri_up',  min:bounds.gain[0],  max:bounds.gain[1],  step:bounds.gain[2],  def:defaults.gain_bri_up });
  addSliderRow(mB, { label:'Offset',    key:'offset_bri_up',min:bounds.offPct[0],max:bounds.offPct[1],step:bounds.offPct[2], def:defaults.offset_bri_up, format:fmtPct });
  // Morning CCT
  addSliderRow(mC, { label:'Steepness', key:'steep_cct_up', min:bounds.steep[0], max:bounds.steep[1], step:bounds.steep[2], def:defaults.steep_cct_up });
  addSliderRow(mC, { label:'Gain',      key:'gain_cct_up',  min:bounds.gain[0],  max:bounds.gain[1],  step:bounds.gain[2],  def:defaults.gain_cct_up });
  addSliderRow(mC, { label:'Offset',    key:'offset_cct_up',min:bounds.offPct[0],max:bounds.offPct[1],step:bounds.offPct[2], def:defaults.offset_cct_up, format:fmtPct });

  // Evening Brightness
  addSliderRow(eB, { label:'Steepness', key:'steep_bri_dn', min:bounds.steep[0], max:bounds.steep[1], step:bounds.steep[2], def:defaults.steep_bri_dn });
  addSliderRow(eB, { label:'Gain',      key:'gain_bri_dn',  min:bounds.gain[0],  max:bounds.gain[1],  step:bounds.gain[2],  def:defaults.gain_bri_dn });
  addSliderRow(eB, { label:'Offset',    key:'offset_bri_dn',min:bounds.offPct[0],max:bounds.offPct[1],step:bounds.offPct[2], def:defaults.offset_bri_dn, format:fmtPct });
  // Evening CCT
  addSliderRow(eC, { label:'Steepness', key:'steep_cct_dn', min:bounds.steep[0], max:bounds.steep[1], step:bounds.steep[2], def:defaults.steep_cct_dn });
  addSliderRow(eC, { label:'Gain',      key:'gain_cct_dn',  min:bounds.gain[0],  max:bounds.gain[1],  step:bounds.gain[2],  def:defaults.gain_cct_dn });
  addSliderRow(eC, { label:'Offset',    key:'offset_cct_dn',min:bounds.offPct[0],max:bounds.offPct[1],step:bounds.offPct[2], def:defaults.offset_cct_dn, format:fmtPct });

  // Reset buttons
  document.getElementById('reset-morning').onclick = () => {
    ['mid_bri_up','steep_bri_up','gain_bri_up','offset_bri_up','mid_cct_up','steep_cct_up','gain_cct_up','offset_cct_up'].forEach(k=>{
      params[k]=defaults[k]; const ui=UI.sliders[k]; if(ui){ ui.input.value=params[k]; ui.val.textContent=ui.format?ui.format(params[k]):params[k]; ui._repositionPin?.(); }
    });
    params.mid_cct_up = params.mid_bri_up; const uiMid = UI.sliders['mid_cct_up']; if (uiMid){ uiMid.input.value=params.mid_cct_up; uiMid.val.textContent=uiMid.format?uiMid.format(params.mid_cct_up):params.mid_cct_up; uiMid._repositionPin?.(); }
    if (params.mirror_up) setCCTMirrorUI('up', true);
    draw();
  };
  document.getElementById('reset-evening').onclick = () => {
    ['mid_bri_dn','steep_bri_dn','gain_bri_dn','offset_bri_dn','mid_cct_dn','steep_cct_dn','gain_cct_dn','offset_cct_dn'].forEach(k=>{
      params[k]=defaults[k]; const ui=UI.sliders[k]; if(ui){ ui.input.value=params[k]; ui.val.textContent=ui.format?ui.format(params[k]):params[k]; ui._repositionPin?.(); }
    });
    params.mid_cct_dn = params.mid_bri_dn; const uiMid = UI.sliders['mid_cct_dn']; if (uiMid){ uiMid.input.value=params.mid_cct_dn; uiMid.val.textContent=uiMid.format?uiMid.format(params.mid_cct_dn):params.mid_cct_dn; uiMid._repositionPin?.(); }
    if (params.mirror_dn) setCCTMirrorUI('dn', true);
    draw();
  };

  // Mirror toggles
  const upChk = document.getElementById('mirror-up');
  const dnChk = document.getElementById('mirror-dn');
  if (upChk) { upChk.checked = params.mirror_up; upChk.onchange = (e)=>{ params.mirror_up = e.target.checked; setCCTMirrorUI('up', params.mirror_up); draw(); }; setCCTMirrorUI('up', params.mirror_up); }
  if (dnChk) { dnChk.checked = params.mirror_dn; dnChk.onchange = (e)=>{ params.mirror_dn = e.target.checked; setCCTMirrorUI('dn', params.mirror_dn); draw(); }; setCCTMirrorUI('dn', params.mirror_dn); }
}

function addRangesUI(){
  const minT=document.getElementById('min-temp'), maxT=document.getElementById('max-temp');
  const minI=document.getElementById('min-intensity'), maxI=document.getElementById('max-intensity');
  const tempFill=document.getElementById('temp-fill'), intFill=document.getElementById('intensity-fill');
  const minTVal=document.getElementById('min-temp-value'), maxTVal=document.getElementById('max-temp-value');
  const minIVal=document.getElementById('min-intensity-value'), maxIVal=document.getElementById('max-intensity-value');

  function updateTempFill(){ const left=((+minT.value-500)/(6500-500))*100, width=((+maxT.value-+minT.value)/(6500-500))*100; tempFill.style.left=`${left}%`; tempFill.style.width=`${width}%`; }
  function updateIntFill(){ const left=((+minI.value)/100)*100, width=((+maxI.value-+minI.value)/100)*100; intFill.style.left=`${left}%`; intFill.style.width=`${width}%`; }
  function commit(){
    if(+minT.value>+maxT.value){ const t=minT.value; minT.value=maxT.value; maxT.value=t; }
    if(+minI.value>+maxI.value){ const t=minI.value; minI.value=maxI.value; maxI.value=t; }
    params.min_color_temp=+minT.value; params.max_color_temp=+maxT.value;
    params.min_brightness=+minI.value; params.max_brightness=+maxI.value;
    minTVal.textContent=params.min_color_temp; maxTVal.textContent=params.max_color_temp;
    minIVal.textContent=params.min_brightness; maxIVal.textContent=params.max_brightness;
    updateTempFill(); updateIntFill(); draw();
  }
  minT.oninput=commit; maxT.oninput=commit; minI.oninput=commit; maxI.oninput=commit;
  commit();
}

function addSunUI(){
  const selMonth=document.getElementById('month'); const mLabel=document.getElementById('month-label');
  selMonth.innerHTML=''; MONTHS.forEach((n,i)=>{ const o=document.createElement('option'); o.value=String(i+1); o.textContent=n; if(i+1===params.month) o.selected=true; selMonth.appendChild(o); });
  selMonth.onchange=e=>{ params.month=+e.target.value; mLabel.textContent=MONTHS[params.month-1]; draw(); };
  mLabel.textContent=MONTHS[params.month-1];

  const lat=document.getElementById('lat'), lon=document.getElementById('lon');
  const latL=document.getElementById('lat-label'), lonL=document.getElementById('lon-label');
  const commitLL=()=>{ const la=parseFloat(lat.value), lo=parseFloat(lon.value); if(!Number.isNaN(la)) { params.latitude=la; latL.textContent=la; } if(!Number.isNaN(lo)) { params.longitude=lo; lonL.textContent=lo; } draw(); };
  lat.onblur=commitLL; lon.onblur=commitLL; lat.onkeydown=e=>{if(e.key==='Enter') lat.blur();}; lon.onkeydown=e=>{if(e.key==='Enter') lon.blur();};

  const tz=document.getElementById('tz'), tzL=document.getElementById('tz-label');
  tz.innerHTML=''; TZ_OPTIONS.forEach(id=>{ const o=document.createElement('option'); o.value=id; o.textContent=id; if(id===params.timezone) o.selected=true; tz.appendChild(o); });
  tz.onchange=e=>{ params.timezone=e.target.value; tzL.textContent=params.timezone; draw(); };

  const fmt12=document.getElementById('fmt12'), f12L=document.getElementById('fmt12-label');
  fmt12.checked=params.use12Hour; f12L.textContent=params.use12Hour?'Enabled':'Disabled';
  fmt12.onchange=e=>{ params.use12Hour=e.target.checked; f12L.textContent=params.use12Hour?'Enabled':'Disabled'; draw(); };
}

/* =========================
   Draw & reset
========================= */
function draw(){ const series=compute(); renderPlot(series); updatePreviewDeltas(); }
function resetAll(){
  Object.keys(defaults).forEach(k=>params[k]=defaults[k]);
  selectedHour = new Date().getHours()+new Date().getMinutes()/60;
  addMorningEveningUI(); addRangesUI(); addSunUI();
  document.getElementById('step-count').value='15';
  draw();
}

/* =========================
   Bootstrap
========================= */
addMorningEveningUI();
addRangesUI();
addSunUI();
document.getElementById('reset-all').onclick=resetAll;
draw();
</script>
</body>
</html>
